// PRTView.cpp : implementation of the CPRTView class
//

//#define NOMINMAX
#include "stdafx.h"
#include <conio.h>
#include <direct.h>
#include <iostream>

#include "PRT.h"
#include "PRTDoc.h"
#include "PRTView.h"
#include ".\prtview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

Matrix4fT   g_modelTransform = {  1.0f,  0.0f,  0.0f,  0.0f,	0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,   0.0f,  0.0f,  0.0f,  1.0f };
Matrix3fT   g_eyeLastRot = {  1.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  1.0f };
Matrix3fT   g_eyeThisRot = {  1.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  1.0f };
ArcBallT    g_eyeArcBall(640.0f, 480.0f);

Matrix4fT   g_envTransform = {  1.0f,  0.0f,  0.0f,  0.0f,	0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,   0.0f,  0.0f,  0.0f,  1.0f };
Matrix3fT   g_envLastRot = {  1.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  1.0f };
Matrix3fT   g_envThisRot = {  1.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  1.0f };
ArcBallT    g_envArcBall(640.0f, 480.0f);

typedef void (APIENTRY * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void (APIENTRY * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
typedef void (APIENTRY * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
typedef void (APIENTRY * PFNGLBUFFERDATAARBPROC) (GLenum target, int size, const GLvoid *data, GLenum usage);
// VBO Extension Function Pointers
PFNGLGENBUFFERSARBPROC glGenBuffersARB = NULL;					// VBO Name Generation Procedure
PFNGLBINDBUFFERARBPROC glBindBufferARB = NULL;					// VBO Bind Procedure
PFNGLBUFFERDATAARBPROC glBufferDataARB = NULL;					// VBO Data Loading Procedure
PFNGLDELETEBUFFERSARBPROC glDeleteBuffersARB = NULL;			// VBO Deletion Procedure

#define n6k (6 * m_cubeRes * m_cubeRes)
#define n1k (m_cubeRes * m_cubeRes)
#define  StencilVis

// CPRTView

IMPLEMENT_DYNCREATE(CPRTView, CView)

BEGIN_MESSAGE_MAP(CPRTView, CView)
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_MBUTTONDOWN()
	ON_WM_MBUTTONUP()
	ON_WM_ERASEBKGND()
	ON_COMMAND(ID_EDIT_INITGL, OnInitGL)
	ON_COMMAND(ID_EDIT_DRAWNORMAL, OnDrawNormal)
	ON_COMMAND(ID_EDIT_FILLMODE, OnFillMode)
	ON_COMMAND(ID_EDIT_COMPUTESAVEVISBS, OnComputeSaveVisibs)
	ON_COMMAND(ID_EDIT_DRAWNORMALMAP, OnDrawNormalMap)
	ON_WM_KEYDOWN()
	ON_COMMAND(ID_EDIT_DRAWVISRATIO, OnDrawVisRatio)
	ON_WM_MOUSEWHEEL()
	ON_COMMAND(ID_FILE_OPENCUBEMAP, OnOpenCubeMap)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DRAWNORMAL, OnUpdateEditDrawNormal)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DRAWNORMALMAP, OnUpdateEditDrawNormalMap)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DRAWVISRATIO, OnUpdateEditDrawVisRatio)
	ON_COMMAND(ID_EDIT_DRAWLIGHT, OnEditDrawLight)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DRAWLIGHT, OnUpdateEditDrawLight)
	ON_COMMAND(ID_EDIT_COMPUTESAVET1, OnComputeSaveT1)
	ON_COMMAND(ID_VIEW_32799, OnDiffuseE)
	ON_COMMAND(ID_VIEW_32796, OnFwi1)
	ON_COMMAND(ID_VIEW_32797, OnFwo1)
	ON_UPDATE_COMMAND_UI(ID_VIEW_32799, OnUpdateDiffuseE)
	ON_UPDATE_COMMAND_UI(ID_VIEW_32796, OnUpdateFwi1)
	ON_UPDATE_COMMAND_UI(ID_VIEW_32797, OnUpdateFwo1)
	ON_COMMAND(ID_USECOEFNUM_32, OnUseCoefNum32)
	ON_COMMAND(ID_USECOEFNUM_64, OnUsecoefnum64)
	ON_COMMAND(ID_USECOEFNUM_96, OnUsecoefnum96)
	ON_COMMAND(ID_USECOEFNUM_128, OnUsecoefnum128)
	ON_COMMAND(ID_USECOEFNUM_256, OnUsecoefnum256)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_32, OnUpdateUsecoefnum32)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_64, OnUpdateUsecoefnum64)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_96, OnUpdateUsecoefnum96)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_128, OnUpdateUsecoefnum128)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_256, OnUpdateUsecoefnum256)
	ON_COMMAND(ID_USECOEFNUM_4, OnUsecoefnum4)
	ON_COMMAND(ID_USECOEFNUM_8, OnUsecoefnum8)
	ON_COMMAND(ID_USECOEFNUM_16, OnUsecoefnum16)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_4, OnUpdateUsecoefnum4)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_8, OnUpdateUsecoefnum8)
	ON_UPDATE_COMMAND_UI(ID_USECOEFNUM_16, OnUpdateUsecoefnum16)
	ON_COMMAND(ID_Menu, OnDrawSubsurfVisRatio)
	ON_UPDATE_COMMAND_UI(ID_Menu, OnUpdateDrawSubsurfVisRatio)
	ON_COMMAND(ID_EDIT_COMPUTESAVEDM, OnComputeSaveDm)
	ON_COMMAND(ID_EDIT_DRAWDM, OnDrawDm)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DRAWDM, OnUpdateDrawDm)
	ON_COMMAND(ID_EDIT_MSTRANS2PASS, OnMSTrans2Pass)
	ON_COMMAND(ID_EDIT_COMPUTESAVEE, OnEditComputeSaveE)
	ON_COMMAND(ID_EDIT_BUILDTREE, OnBuildTree)
	ON_COMMAND(ID_EDIT_LOADTD, OnLoadTd)
	ON_COMMAND(ID_EDIT_LOADT1, OnLoadT1Coefs)
	ON_COMMAND(ID_USEPHASETERM_4, OnUsephaseterm4)
	ON_UPDATE_COMMAND_UI(ID_USEPHASETERM_4, OnUpdateUsephaseterm4)
	ON_COMMAND(ID_USEPHASETERM_8, OnUsephaseterm8)
	ON_UPDATE_COMMAND_UI(ID_USEPHASETERM_8, OnUpdateUsephaseterm8)
	ON_COMMAND(ID_USEPHASETERM_16, OnUsephaseterm16)
	ON_UPDATE_COMMAND_UI(ID_USEPHASETERM_16, OnUpdateUsephaseterm16)
	ON_COMMAND(ID_USEPHASETERM_32, OnUsephaseterm32)
	ON_UPDATE_COMMAND_UI(ID_USEPHASETERM_32, OnUpdateUsephaseterm32)
	ON_COMMAND(ID_USEPHASETERM_1, OnUsephaseterm1)
	ON_UPDATE_COMMAND_UI(ID_USEPHASETERM_1, OnUpdateUsephaseterm1)
	ON_COMMAND(ID_VIEW_32828, OnSpec)
	ON_UPDATE_COMMAND_UI(ID_VIEW_32828, OnUpdateSpec)
	ON_COMMAND(ID_VIEW_DRAWTEXTURE, OnViewDrawtexture)
	ON_UPDATE_COMMAND_UI(ID_VIEW_DRAWTEXTURE, OnUpdateViewDrawtexture)
	ON_COMMAND(ID_FILE_OPENTEXTURE, OnFileOpentexture)
END_MESSAGE_MAP()

// CPRTView construction/destruction

CPRTView::CPRTView()
:	  m_bLoadedObj(false)
	, m_bLoadedVisibs(false)
	, m_bLoadedRd(false)
	, m_bDrawNormal(false)
	, m_bDrawNormalMap(false)
	, m_bDrawVisRatio(false)
	, m_fillMode(0)
	, m_cubeRes(32)
	, m_ECoefNum(256)
	, m_bLoadedTdCoefs(false)
	, m_bLoadedCubeMap(false)
	, m_bDrawMS(false)
	, m_colorCoef(1.0f)
	, m_hdrCoef(1.0f)
	, m_bDrawLight(false)
	, m_bDrawSS(false)
	, m_SSSampleNum(16)
	, m_bLoadedT1Coefs(false)
	, _DiffuseE(false)
	, _Fwi1(true)
	, _Fwo1(true)
	, m_bMSUncomp(false)
	, m_fTd0(NULL)
	, m_fE0(NULL)
	, m_bLoadedE0T0(false)
	, m_nFPS(0)
	, m_nFrames(0)
	, m_dwLastFPS(0)
	, m_objBboxSize(5)
	, m_svrKeyDownIdx(0)
	, m_bDrawSubsurfVisratio(false)
	, m_yita(1.3f)	//index of relative refraction
	, m_bLoadedDm(false)
	, m_bDrawDm(false)
	, _MC(true)
	, m_useCoefNum(256)
	, m_pECoefsTree(NULL)
	, m_epsMSTdKd(0.02f)	//jiaping's is 0.02f 
	, m_bDrawBBox(false)
	, m_TdCoefNum(256)
	, m_T1CoefNum(256)
	, m_displayListId(0)
	, m_nVBOVertices(0)
	, m_nVBOColors(0)
	, m_phaseSVDterm(4)
	, _HG1(false)
	, m_HGres(16)
	, m_usePhaseTerm(4)
	, _Spec(true)
	, m_specCoef(35.f)
	, _Tex(true)
	, m_texAlpha(128)
	{
		//deb
		m_usePhaseTerm = 1;
		m_phaseSVDterm = 4;

		m_SSSampleNum = 8;

		m_g = 0.25f; //SSIso!!! NOTE: m_g impact sampleIntrude!!!!
		
		m_epsMSTdKd = 0.01f;
		m_leafSampleNum = 16;

		m_eye = Vec3(0, 0, 3 * m_objBboxSize);

		m_MSWeight = 0.022f; //to do: add a scroll bar to modify-on-fly
		m_SSWeight = 1;

		////////////////////////////////////////////////////////////////////////// bssrdf

		////whole milk
		//m_sigmaSPrime = Vec3(2.55f, 3.21f, 3.77f);//r,g,b (1-g)*sigmaS, sigmaS is scattering coef, not appeared. .Jensen01 Fig.5
		//m_sigmaA = Vec3(0.0011f, 0.0024f, 0.014f);//absorption coef
		
		//marble
		//m_sigmaSPrime = Vec3(2.19f, 2.62f, 3.f);
		//m_sigmaA = Vec3(0.0021f, 0.0041f, 0.0071f);

		////Wang05's teaser
		m_sigmaSPrime = Vec3(0.75f, 0.85f, 1.00f);//r,g,b (1-g)*sigmaS, sigmaS is scattering coef, not appeared. .Jensen01 Fig.5
		m_sigmaA = Vec3(0.02f, 0.04f, 0.07f);//absorption coef

		m_sigmaS = m_sigmaSPrime / (1 - m_g);				//sigmaS = sigmaS'/(1-g)
		m_sigmaT = m_sigmaA + m_sigmaS;
		m_sigmaTLumi = 0.299f * m_sigmaT.x + 0.587f * m_sigmaT.y + 0.114f * m_sigmaT.z;	//sigmaT's luminance: L*A*B color space projection of sigmaT

		//float m_zr[3];
		//float m_zv[3];
		//float m_sigmaTr[3];
		//float m_alphaPrime[3];
		//m_g = 0;

		float Fdr = -1.440f/(m_yita*m_yita) + 0.710f/m_yita + 0.668f + 0.0636f*m_yita;
		
		Vec3 sigmaTPrime;
		sigmaTPrime = m_sigmaA + m_sigmaSPrime; //extinction coef
		m_sigmaTr = SQRTF(DP(m_sigmaA, sigmaTPrime) * 3);	
		m_alphaPrime = DD(m_sigmaSPrime, sigmaTPrime);

		m_zr = 1 / sigmaTPrime;
		m_zv = m_zr * (1 + 4.f/3.f * (1+Fdr)*(1-Fdr));

		//////////////////////////////////////////////////////////////////////////
		m_curLightCoefs = new Vec3[n6k];
		
		m_bLBDown  = false;										
		m_bRBDown = false;	
		m_bMBDown = false;
		m_oldY = 0;//for zoom
		m_dFOV = 50; //in degree
		m_oldFOV = m_dFOV;

		m_cubeMap.m_downRes = m_cubeRes;

		m_errorString = new GLubyte[256];

		m_textureImage.clear();
		//test
		//ComputeSaveHGMat(16);
}

CPRTView::~CPRTView()
{
	if(m_curLightCoefs)
		delete[] m_curLightCoefs;

	if(m_fTd0)
		fclose(m_fTd0);
	if(m_fE0)
		fclose(m_fE0);
	if(m_errorString)
	{
		delete[] m_errorString;
		m_errorString = NULL;
	}
	if(m_pECoefsTree)
	{
		delete m_pECoefsTree;
		m_pECoefsTree = NULL;
	}	
}

BOOL CPRTView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CView::PreCreateWindow(cs);
}

void CPRTView::OnDraw(CDC* /*pDC*/)
{
}

BOOL CPRTView::OnPreparePrinting(CPrintInfo* pInfo)
{
	return DoPreparePrinting(pInfo);
}

void CPRTView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}

void CPRTView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}

#ifdef _DEBUG
void CPRTView::AssertValid() const
{
	CView::AssertValid();
}

void CPRTView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CPRTDoc* CPRTView::GetDocument() const // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CPRTDoc)));
	return (CPRTDoc*)m_pDocument;
}
#endif //_DEBUG

int CPRTView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO:  Add your specialized creation code here
	SetupPixelFormat();
	wglMakeCurrent(NULL,NULL);

	return 0;
}

BOOL CPRTView::SetupPixelFormat()
{
	GLuint PixelFormat;
	static PIXELFORMATDESCRIPTOR pfd= {
		sizeof(PIXELFORMATDESCRIPTOR),  // Size Of This Pixel Format Descriptor
			1,                              // Version Number (?)
			PFD_DRAW_TO_WINDOW |            // Format Must Support Window
			PFD_SUPPORT_OPENGL |            // Format Must Support OpenGL
			PFD_DOUBLEBUFFER,               // Must Support Double Buffering
			PFD_TYPE_RGBA,                  // Request An RGBA Format
			32,                             // Select A 32Bit Color Depth
			0, 0, 0, 0, 0, 0,               // Color Bits Ignored (?)
			0,                              // No Alpha Buffer
			0,                              // Shift Bit Ignored (?)
			0,                              // No Accumulation Buffer
			0, 0, 0, 0,                     // Accumulation Bits Ignored (?)
			24,                             // 24Bit Z-Buffer (Depth Buffer) 
			8,                              // 8 bit stencil buffer
			0,                              // No Auxiliary Buffer (?)
			PFD_MAIN_PLANE,                 // Main Drawing Layer
			0,                              // Reserved (?)
			0, 0, 0                         // Layer Masks Ignored (?)
	};

	m_hDC = ::GetDC(m_hWnd);    // Gets A Device Context For The Window
	PixelFormat = ChoosePixelFormat(m_hDC, &pfd); // Finds The Closest Match To The Pixel Format We Set Above

	if (!PixelFormat)
	{
		::MessageBox(0,"Can't Find A Suitable PixelFormat.","Error",MB_OK|MB_ICONERROR);
		PostQuitMessage(0);
		// This Sends A 'Message' Telling The Program To Quit
		return false ;    // Prevents The Rest Of The Code From Running
	}

	if(!SetPixelFormat(m_hDC,PixelFormat,&pfd))
	{
		::MessageBox(0,"Can't Set The PixelFormat.","Error",MB_OK|MB_ICONERROR);
		PostQuitMessage(0);
		return false;
	}

	m_hRC = wglCreateContext(m_hDC);
	if(!m_hRC)
	{
		::MessageBox(0,"Can't Create A GL Rendering Context.","Error",MB_OK|MB_ICONERROR);
		PostQuitMessage(0);
		return false;
	}

	if(!wglMakeCurrent(m_hDC, m_hRC))
	{
		::MessageBox(0,"Can't activate GLRC.","Error",MB_OK|MB_ICONERROR);
		PostQuitMessage(0);
		return false;
	}
	InitGL();
	return true;
}

void CPRTView::InitGL()
{
	glEnable(GL_DEPTH_TEST);
	glClearDepth(1.0f);
	glShadeModel(GL_SMOOTH);
	glDisable(GL_LIGHTING);
	glDisable(GL_CULL_FACE);

	Matrix3fSetIdentity(&g_eyeLastRot);								// Reset Rotation
	Matrix3fSetIdentity(&g_eyeThisRot);								// Reset Rotation
	Matrix4fSetRotationFromMatrix3f(&g_modelTransform, &g_eyeThisRot);		// Reset Rotation
	Matrix3fSetIdentity(&g_envLastRot);								// Reset Rotation
	Matrix3fSetIdentity(&g_envThisRot);								// Reset Rotation
	Matrix4fSetRotationFromMatrix3f(&g_envTransform, &g_envThisRot);		// Reset Rotation

	// Setup lighting
	GLfloat mat_diffuse[] = {1.0, 1.0, 1.0, 1.0};
	GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
	GLfloat mat_shininess[] = {100.0};
	GLfloat light_position[] = {1.0, 1.0, 1.0, 0.0};
	GLfloat white_light[] = {1.0, 1.0, 1.0, 1.0};
	
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light);
	glLightfv(GL_LIGHT0, GL_SPECULAR, white_light);
	
	ChangeDrawElements();
}

void CPRTView::ChangeDrawElements()
{
	glEnableClientState(GL_COLOR_ARRAY);
	glEnableClientState(GL_VERTEX_ARRAY);
	glEnableClientState(GL_NORMAL_ARRAY);

	if(m_bLoadedObj)
	{
		if(m_bDrawNormalMap)
		{
			//glColorPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->vpVertexTexcoords[0]);
			glColorPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->vpVertexNormals[0]);
		}
		else if(m_bDrawVisRatio)
		{
			glColorPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->visRatios[0]);
		}
		else if(m_bDrawSubsurfVisratio)
		{
			glColorPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->vpSubsurfVisRatio[m_svrKeyDownIdx * (m_accessObj.m_pModel->nVertices + 1)]);
		}
		else if(m_bDrawDm && m_bLoadedDm)
		{
			glColorPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->vpDm[0]);
		}
		else if(m_bDrawMS || m_bDrawSS)
		{
			glColorPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->vpColors[0]);
		}
		else
		{
			glDisableClientState(GL_COLOR_ARRAY);
			glColor3f(1,1,1);
		}

		if(_Tex && (!m_accessObj.m_pModel->vpVertexTexcoords.empty()))
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
			glDeleteTextures(1, &m_meshTex);
			glGenTextures(1, &m_meshTex);
			glBindTexture(GL_TEXTURE_2D, m_meshTex);
			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE,GL_DECAL);// GL_MODULATE);//
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_texW, m_texH, 0, GL_RGBA, GL_UNSIGNED_BYTE, &m_textureImage[0]);

			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

			glEnable(GL_TEXTURE_2D);
			glEnableClientState(GL_TEXTURE_COORD_ARRAY);
			glTexCoordPointer(3, GL_FLOAT, 0, &m_accessObj.m_pModel->vpVertexTexcoords[0]);
		}
		else
		{
			glDisable(GL_TEXTURE_2D);
			glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		}

		glVertexPointer(3, GL_FLOAT,0, &m_accessObj.m_pModel->vpVertices[0]);
		glNormalPointer(GL_FLOAT, 0, &m_accessObj.m_pModel->vpVertexNormals[0]);
	}
}

void CPRTView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	
	m_nHeight= cy;
	m_nWidth = cx;
	g_envArcBall.setBounds((GLfloat)m_nWidth, (GLfloat)m_nHeight);
	g_eyeArcBall.setBounds((GLfloat)m_nWidth, (GLfloat)m_nHeight);
}

void CPRTView::OnFileOpen()
{
	char szFilter[] = "obj Files (*.obj)|*.obj|obj Files (*.obj)|*.obj|All Files (*.*)|*.*||";
	char workdir[128];

	CFileDialog openDlg(TRUE,NULL,
		NULL,
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		szFilter,
		this);
	CString szFilepath;

	_getcwd( workdir, 128);

	if(openDlg.DoModal() == IDOK)
	{
		BeginWaitCursor();
		m_bLoadedObj = false;
		m_bLoadedVisibs =false;	
		m_bLoadedRd = false;
		m_bLoadedTdCoefs = false;
		m_bDrawVisRatio = false;
		m_bDrawNormalMap = false;
		m_bDrawMS = false;
		m_bDrawSS = false;
		m_bLoadedT1Coefs = false;
		m_bMSUncomp = false;
		m_bDrawSubsurfVisratio = false;
		m_bLoadedSubsurfVisRatio = false;
		m_bLoadedDm = false;
		m_bDrawDm = false;
		m_bDrawLight = false;

		if(m_fTd0)
		{
			fclose(m_fTd0);
			m_fTd0 = NULL;
		}
		if(m_fE0)
		{
			fclose(m_fE0);
			m_fE0 = NULL;
		}
		m_bLoadedE0T0 = false;

		szFilepath = openDlg.GetPathName();
		if(m_accessObj.LoadOBJ((char*)(LPCSTR)szFilepath))
		{	
			m_accessObj.CenterScaleObj(m_objBboxSize);
			m_accessObj.ComputeNormals();
			m_accessObj.VertTexcoords();

			//tex
			for (UINT i = 0; i < m_accessObj.m_pModel->nMaterials; i ++)
			{
				if(m_accessObj.m_pModel->pMaterials[i].bTextured)
				{
					m_texW = m_accessObj.m_pModel->pMaterials[i].nWidth;
					m_texH = m_accessObj.m_pModel->pMaterials[i].nHeight;
					m_textureImage.clear();
					m_textureImage.resize(m_texW * m_texH * 4);

					unsigned char* pTex = &m_textureImage[0];
					unsigned char* pImg = m_accessObj.m_pModel->pMaterials[i].pTexImage;
					for(int n = 0; n < m_texW * m_texH * 3; ++n)
					{
						*pTex = *pImg;
						if(n % 3 == 2)
						{
							++pTex;
							*pTex = 255;
						}
						++pTex;
						++pImg;
					}	
				}
			}

			//indices
			m_accessObj.m_pModel->TrianglesIndices.resize(m_accessObj.m_pModel->nTriangles * 3);
			for(unsigned int i = 0; i < m_accessObj.m_pModel->nTriangles; i++)
			{
				for(int j = 0; j < 3; ++j)
					m_accessObj.m_pModel->TrianglesIndices[i * 3 + j] = m_accessObj.m_pModel->pTriangles[i].vindices[j];
			}
			m_accessObj.m_pModel->nVisibRes = m_cubeRes;
			m_accessObj.m_pModel->nECoefNum = m_ECoefNum;
			m_accessObj.m_pModel->nTdCoefNum = m_TdCoefNum;
			m_accessObj.m_pModel->nT1CoefNum = m_T1CoefNum;
			m_accessObj.m_pModel->nSubsurfSampleNum = m_SSSampleNum;
			m_accessObj.m_pModel->nPhaseSVDterm = m_phaseSVDterm;

			m_filenameNoSuffix = szFilepath.Left((int)strlen(szFilepath) - 4);

			//////////////////////////////////////////////////////////////////////////MS
			//CString m_visibFilename = m_filenameNoSuffix + ".vsb";
			//if(m_accessObj.LoadVisibs((char*)(LPCSTR)m_visibFilename))	
			//{
			//	m_bLoadedVisibs = true;
			//}

			//CString eName = m_filenameNoSuffix + ".E";
			//if(m_accessObj.LoadECoefs((char*)(LPCSTR)eName))	
			//{
			//	m_bLoadedECoefs = true;
			//}

			//CString TdName = m_filenameNoSuffix + ".Td2";
			//if(m_accessObj.LoadTd2Coefs((char*)(LPCSTR)TdName))	
			//{
			//	m_bLoadedTdCoefs = true;
			//}

			//if(m_bLoadedTdCoefs && m_bLoadedCubeMap)
			//	m_bDrawMS = true;
			//////////////////////////////////////////////////////////////////////////SS
			
			//CString subsurfVisRatioName = m_filenameNoSuffix + ".svr";
			//if(m_accessObj.LoadSubsurfVisRatio((char*)(LPCSTR)subsurfVisRatioName))	
			//{
			//	m_bLoadedSubsurfVisRatio = true;
			//}

			CString fnDm = m_filenameNoSuffix + ".Dm";
			if(m_accessObj.LoadDm((char*)(LPCSTR)fnDm))
			{
				m_bLoadedDm = true;
			}	

			CString T1Cname = m_filenameNoSuffix + ".T1C";
			if(m_accessObj.LoadT1Coefs((char*)(LPCSTR)T1Cname))	
			{
				m_bLoadedT1Coefs = true;
			}

			if(m_bLoadedT1Coefs && m_bLoadedCubeMap)
				m_bDrawSS = true;
			
			const int nHGsize = 6 * m_HGres * m_HGres;
			m_pH.resize(m_phaseSVDterm * nHGsize, 1.f);
			if(!_HG1)
			{
				//HG16g-25t32.hgH 
				CString fHgHn;
				if(fabs(m_g - 0.25f) < Epsilon)
					fHgHn = "HG16g25t32.hgH";
				else if(fabs(m_g - (-0.25f)) < Epsilon)
					fHgHn = "HG16g-25t32.hgH";
				else if(fabs(m_g - (-0.4f)) < Epsilon)
					fHgHn = "HG16g-40t32.hgH";
				else if(fabs(m_g - 0.4f) < Epsilon)
					fHgHn = "HG16g40t32.hgH";
				else if(fabs(m_g - 0.9f) < Epsilon)
					fHgHn = "HG16g90t32.hgH";
				else if(fabs(m_g - (-0.90f)) < Epsilon)
					fHgHn = "HG16g-90t32.hgH";
				else if(fabs(m_g - 0) < Epsilon)
					fHgHn = "HG16g0t32.hgH";
				
				FILE* fHgH;
				if((fHgH = fopen(((char*)(LPCSTR)fHgHn), "rb")) == NULL)
				{
					printf("failed open reading .hgH.\n ");
					return;
				}
				size_t n = fread(&m_pH[0], sizeof(float), m_phaseSVDterm * nHGsize, fHgH);
				assert(n == (size_t)(nHGsize * m_phaseSVDterm));
				fclose(fHgH);
			}

			//////////////////////////////////////////////////////////////////////////
			m_accessObj.m_pModel->vpTransedRadiance.clear();
			m_accessObj.m_pModel->vpTransedRadiance.resize(m_accessObj.m_pModel->nVertices);
			m_accessObj.m_pModel->vpColors.clear();
			m_accessObj.m_pModel->vpColors.resize(m_accessObj.m_pModel->nVertices + 1);
			m_bLoadedObj = true;
		}
		EndWaitCursor();
		_chdir(workdir);
		InitGL();
	}
	InvalidateRect(NULL,FALSE);
}


void CPRTView::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	DrawScene();
}

void CPRTView::DrawScene()
{	
	wglMakeCurrent(m_hDC,m_hRC);
	glDrawBuffer( GL_BACK );
	glClearColor(0, 0, 0, 1);;
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	
	if(!m_bLoadedObj)
	{
		glFlush();
		SwapBuffers(m_hDC);
		return;
	}
	assert((m_accessObj.m_pModel->nVertices != 0) && (m_accessObj.m_pModel->nTriangles !=0));

	glViewport(0, 0, m_nWidth, m_nHeight);    
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(m_dFOV, (GLfloat)m_nWidth / (GLfloat)m_nHeight, 0.1f, 2000.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(m_eye.x, m_eye.y, m_eye.z,
		0.0, 0.0, 0.0,
		0,1,0);

	//view
	glPushMatrix();	
	glMultMatrixf(g_modelTransform.M);

	//if(m_nVBOVertices == 1)
	//{
	//	glBindBufferARB( GL_ARRAY_BUFFER_ARB, m_nVBOVertices);
	//	glVertexPointer( 3, GL_FLOAT, 0, (char *) NULL );		// Set The Vertex Pointer To The Vertex Buffer
	//	glBindBufferARB( GL_ARRAY_BUFFER_ARB, m_nVBOColors);
	//	glColorPointer( 3, GL_FLOAT, 0, (char *) NULL );		// Set The TexCoord Pointer To The TexCoord Buffer
	////}

	if(m_bLoadedCubeMap && _Tex && (m_meshTex > 0))
		glBindTexture( GL_TEXTURE_2D, m_meshTex);
	glDrawElements(GL_TRIANGLES, 3 * m_accessObj.m_pModel->nTriangles, GL_UNSIGNED_INT, &m_accessObj.m_pModel->TrianglesIndices[0]);

	if((m_bDrawNormal || m_bDrawDm ) && (!m_accessObj.m_pModel->vpVertexNormals.empty()))
	{
		glColor3f(1,1,1);
		glBegin(GL_LINES);
		for(unsigned int i = 1; i <= m_accessObj.m_pModel->nVertices; i++)
		{
			Vec3* pVert = &m_accessObj.m_pModel->vpVertices[i];
			Vec3* pNormal = &m_accessObj.m_pModel->vpVertexNormals[i];
			glVertex3f(pVert->x, pVert->y, pVert->z);
			if(m_bLoadedDm && m_bDrawDm)
			{
				float Dm = m_accessObj.m_pModel->vpDm[i].x;
				glVertex3f(pVert->x + Dm * pNormal->x, pVert->y + Dm * pNormal->y, pVert->z + Dm * pNormal->z);
			}
			else
				glVertex3f(pVert->x + 0.2f * pNormal->x, pVert->y + 0.2f * pNormal->y, pVert->z + 0.2f * pNormal->z);

		}
		glEnd();
	}
	//env
	glPushMatrix();	
	glMultMatrixf(g_envTransform.M);
	
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(50, (GLfloat)m_nWidth / (GLfloat)m_nHeight, 0.1f, 2000.0f);
	
	if(m_bLoadedCubeMap)
	{
		glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, m_cubeTex);
		DrawCube(1000);//cube size
	}

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glPopMatrix();

	GLenum err = glGetError();
	m_errorString = (GLubyte*)gluErrorString(err);
	if(err != 0)
		printf("%s", m_errorString);

	//// Get FPS
	//if( GetTickCount() - m_dwLastFPS >= 1000 )				// When A Second Has Passed...
	//{
	//	m_nFPS = m_nFrames * 1000 / (GetTickCount() - m_dwLastFPS);						// Save The FPS
	//	m_dwLastFPS = GetTickCount();					// Update Our Time Variable
	//	m_nFrames = 0;							// Reset The FPS Counter
	//	//printf("%d Vertices, %d FPS\n", m_accessObj.m_pModel->nVertices, m_nFPS );
	//	printf("%d FPS\n", m_nFPS);
	//}
	//m_nFrames++;								// Increment Our FPS Counter

	glFlush();
	SwapBuffers(m_hDC);
}

void CPRTView::OnLButtonDown(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;

	m_bLBDown = true;
	g_eyeLastRot = g_eyeThisRot;
	Point2fT MousePt = {(GLfloat)point.x, (GLfloat)point.y};
	g_eyeArcBall.click(&MousePt);

	CView::OnLButtonDown(nFlags, point);
}

void CPRTView::OnLButtonUp(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;
	m_bLBDown = false;
	CView::OnLButtonUp(nFlags, point);
}

void CPRTView::OnRButtonDown(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;
	m_bRBDown = true;
	g_envLastRot = g_envThisRot;
	Point2fT MousePt = {(GLfloat)point.x, (GLfloat)point.y};
	g_envArcBall.click(&MousePt);
	CView::OnRButtonDown(nFlags, point);
}

void CPRTView::OnRButtonUp(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;

	m_bRBDown = false;
	CView::OnRButtonUp(nFlags, point);
}

void CPRTView::OnMButtonDown(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;

	m_oldY = point.y;
	m_bMBDown = true;
}

void CPRTView::OnMButtonUp(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;

	m_oldFOV = m_dFOV;
	m_bMBDown = false;
	CView::OnMButtonUp(nFlags, point);
}

void CPRTView::OnMouseMove(UINT nFlags, CPoint point)
{
	if(!m_bLoadedObj)
		return;

	Point2fT MousePt = {(GLfloat)point.x, (GLfloat)point.y};
	Quat4fT     ThisQuat = {0};

	if(m_bMBDown)
	{
		float scale = 1.0f + (float)(m_oldY - point.y) /(float) m_nHeight;
		if(scale > 0.001)
			m_dFOV = m_oldFOV / scale;
		std::cout<<"m_dFOV: "<<m_dFOV<<endl;
	}

	if(m_bLBDown)//change view, no need to recalc TransedRadiance
	{
		g_eyeArcBall.drag(&MousePt, &ThisQuat);				// Update End v And Get Rotation As Quaternion
		Matrix3fSetRotationFromQuat4f(&g_eyeThisRot, &ThisQuat);		// Convert Quaternion Into Matrix3fT
		Matrix3fMulMatrix3f(&g_eyeThisRot, &g_eyeLastRot);				// Accumulate Last Rotation Into This One
		Matrix4fSetRotationFromMatrix3f(&g_modelTransform, &g_eyeThisRot);	// Set Our Final Transform's Rotation From This One
		
		CalcColor();
	}
	if(m_bRBDown)//change env light
	{
		g_envArcBall.drag(&MousePt, &ThisQuat);				// Update End v And Get Rotation As Quaternion
		Matrix3fSetRotationFromQuat4f(&g_envThisRot, &ThisQuat);		// Convert Quaternion Into Matrix3fT
		Matrix3fMulMatrix3f(&g_envThisRot, &g_envLastRot);				// Accumulate Last Rotation Into This One
		Matrix4fSetRotationFromMatrix3f(&g_envTransform, &g_envThisRot);	// Set Our Final Transform's Rotation From This One
		
		TransedRadiance();
		CalcColor();
	}

	Invalidate(); //calls OnPaint() calls DrawScene()
	CView::OnMouseMove(nFlags, point);
}

BOOL CPRTView::OnEraseBkgnd(CDC* pDC)
{
	return FALSE;
}

void CPRTView::OnInitGL()
{
	InitGL();
}

void CPRTView::OnDrawNormal()
{
	m_bDrawNormal = !m_bDrawNormal;
}

void CPRTView::OnFillMode()
{
	m_fillMode = (m_fillMode + 1) % 3;	

	if(m_fillMode == 0)
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	else if(m_fillMode == 1)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	else if(m_fillMode == 2)
		glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
}

void CPRTView::OnComputeSaveVisibs()
{
	if((!m_bLoadedObj) || m_bLoadedVisibs ) //normal for vert Outrude
	{
		printf("!m_bLoadedObj || (m_bLoadedVisibs)!");
		return;
	}
	CString m_visibFilename = m_filenameNoSuffix + ".vsb";
	FILE* f;
	if((f = fopen(((char*)(LPCSTR)m_visibFilename), "wb")) == NULL)
	{
		printf("failed open m_visibFilename \n ");
		return;
	}

	assert(m_accessObj.m_pModel);

	//###
	glEnableClientState(GL_VERTEX_ARRAY);
	glDisableClientState(GL_COLOR_ARRAY);
	glDisableClientState(GL_NORMAL_ARRAY);
	glVertexPointer(3, GL_FLOAT,0, m_accessObj.m_pModel->vpVertices);

	//
#ifdef StencilVis
	glDrawBuffer(GL_BACK);
	glReadBuffer(GL_BACK);
	glViewport(0, 0, m_cubeRes, m_cubeRes);
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	glDisable(GL_DEPTH_TEST);
	
	glEnable(GL_STENCIL_TEST);
	glClearStencil(0x0);
	glStencilFunc(GL_ALWAYS, 0x1, 0x1);
	glStencilOp (GL_INCR, GL_INCR, GL_INCR);

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluPerspective(90, 1, 0.001f, m_objBboxSize * 2);	//near:intrude[0] is minimal distance that should be covered in [near,far]. 
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();

#else
	glViewport(0, 0, m_cubeRes, m_cubeRes);
	glClearColor(0, 0, 0, 1);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	//Reset The Projection Matrix
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluPerspective(90, 1, 0.01f, m_objBboxSize * 2); //300 should be m_bboxsize*sqrtf(3)
#endif

	m_accessObj.m_pModel->vpVertInvisibs.clear();
	m_accessObj.m_pModel->vpVertInvisibs.resize(m_accessObj.m_pModel->nVertices * n6k);
	m_accessObj.m_pModel->visRatios.clear();
	m_accessObj.m_pModel->visRatios.resize(m_accessObj.m_pModel->nVertices  + 1);

	Vec3 VertOutrude = Vec3(0,0,0);
	float outrude = 0.0001f;
	Vec3 Zero3 = Vec3(0,0,0);
	int nVisibsPerSide = m_cubeRes * m_cubeRes;
	for(unsigned int i = 0; i < m_accessObj.m_pModel->nVertices; i++)
	{
		Vec3* pVert = &m_accessObj.m_pModel->vpVertices[i + 1]; //obj index starts from 1
		Vec3* pNorm = &m_accessObj.m_pModel->vpVertexNormals[i + 1];
		VertOutrude = *pNorm;
		VertOutrude = VertOutrude * outrude;
		VertOutrude = VertOutrude + *pVert;

		unsigned int nVisibleLightSum = 0;
		for(int side = 0; side < 6; side++)
		{
			nVisibleLightSum += VisibleLightSide(&m_accessObj.m_pModel->vpVertInvisibs[i * n6k + side * nVisibsPerSide], &VertOutrude, side);
		}
		float ratio = (float)nVisibleLightSum / (float)(m_cubeRes * m_cubeRes * 6);
		m_accessObj.m_pModel->visRatios[i + 1] = Vec3(ratio, ratio, ratio);
		
		//printf("vert%d's vis ratio is %f\t", i + 1, m_accessObj.m_pModel->visRatios[i + 1].x);
		size_t n = fwrite(&m_accessObj.m_pModel->vpVertInvisibs[i * n6k], sizeof(byte), n6k, f);
		assert(n == (size_t)n6k);

		if(i%100 == 0)
			printf("visib of vert %d of %d vertices finished. \n", i, m_accessObj.m_pModel->nVertices);
	}

	//untested!! flip side0's memory s to res-1-s. 
	for(unsigned int vIdx = 0; vIdx < m_accessObj.m_pModel->nVertices; ++vIdx)
	{
		byte* pVisSide0 = &m_accessObj.m_pModel->vpVertInvisibs[vIdx * n6k];
		Fliplr(pVisSide0, m_cubeRes, m_cubeRes);
	}

	//dump vis ratios
	size_t n = fwrite(&m_accessObj.m_pModel->visRatios[0], sizeof(Vec3), m_accessObj.m_pModel->nVertices + 1, f);
	assert(n == m_accessObj.m_pModel->nVertices + 1);
	fclose(f);

	m_bLoadedVisibs = true;

#ifdef StencilVis
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glDisable(GL_STENCIL_TEST);
	glEnable(GL_DEPTH_TEST);
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
#endif

	InitGL();

	////test
	//unsigned int debugVertIdx = 0; 
	//for(int side = 0; side < 6; side++)
	//{
	//	CString sss = "stencil";
	//	char strSide[2];
	//	_itoa(side, strSide, 10);
	//	sss = sss + strSide + ".pfm";
	//	m_cubeMap.WritePFMRaw(sss, &m_accessObj.m_pModel->vpVertInvisibs[debugVertIdx][side * m_cubeRes * m_cubeRes], m_cubeRes, m_cubeRes);
	//}
}

int CPRTView::VisibleLightSide(byte* pVisibsPerSide, Vec3* pVert, int side)
{
	glClear(GL_STENCIL_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	Vec3 center = Vec3(0,0,0);
	Vec3 up = Vec3(0,0,0);
	m_cubeMap.EyeSide2CenterUp(pVert, side, &center, &up);
	gluLookAt(pVert->x, pVert->y, pVert->z,
		center.x, center.y, center.z,
		up.x, up.y, up.z);

	//###
	glDrawElements(GL_TRIANGLES, 3 * m_accessObj.m_pModel->nTriangles, GL_UNSIGNED_INT, &m_accessObj.m_pModel->TrianglesIndices[0]);
	//glBegin(GL_TRIANGLES);
	//for(unsigned int i = 0; i < m_accessObj.m_pModel->nTriangles; i++)
	//{
	//	for(int j = 0; j < 3;j++)
	//	{
	//		Vec3* pVert = &m_accessObj.m_pModel->vpVertices[(m_accessObj.m_pModel->pTriangles[i]).vindices[j]];
	//		glVertex3f(pVert->x, pVert->y, pVert->z);
	//	}
	//}
	//glEnd();

	glFlush();
	glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, pVisibsPerSide); 

	//count visRatio
	int visCount = 0;
	GLubyte* pStencil = pVisibsPerSide;
	for(int i = 0; i < m_cubeRes * m_cubeRes; ++i)
	{
		//can see bkgd: visible light
		if(*pStencil == 0)
		{
			visCount++;		
		}
		pStencil ++;
	}
	return visCount;	

//	glMatrixMode(GL_MODELVIEW);
//	glLoadIdentity();
//	Vec3 center = Vec3(0,0,0);
//	Vec3 up = Vec3(0,0,0);
//	m_cubeMap.EyeSide2CenterUp(pVert, side, &center, &up);
//	gluLookAt(pVert->x, pVert->y, pVert->z,
//			center.x, center.y, center.z,
//			up.x, up.y, up.z);
//
//	DrawMesh();
//	glReadBuffer(GL_BACK);
//	
//	glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_RED, GL_UNSIGNED_BYTE, pVisibsPerSide);
//
//	//count visRatio
//	int visCount = 0;
//	GLubyte* pColor = pVisibsPerSide;
//	for(int i = 0; i < m_cubeRes * m_cubeRes; ++i)
//	{
//		//can see bkgd: visible light
//		if(*pColor != 255)
//		{
//			assert(*pColor == 0);
//			visCount++;		
//		}
//		pColor ++;
//	}
//	return visCount;	
}

void CPRTView::OnDrawNormalMap()
{
	if(m_bLoadedObj)
		m_bDrawNormalMap = !m_bDrawNormalMap;
	
	ChangeDrawElements();
}

//a: angle between light and normal
inline float  CPRTView::FresnelR(float Cos)
{
	//http://scienceworld.wolfram.com/physics/FresnelEquations.html Eq(7),i.e., electric reflectance. PROBLEM: (7)+(8)should =1, but actually not.Unless remove the '-'. ???

	return 1.f - FresnelT(Cos);
    //return  (Cos > 0) ? (sqrtf(m_yita * m_yita - 1 + Cos * Cos) - Cos) / (Cos + sqrtf(m_yita * m_yita - 1 + Cos * Cos)) : 0;//I change cos-... to ...-cos
}

//a: angle between light and normal
inline float  CPRTView::FresnelT(float Cos)
{
	//http://scienceworld.wolfram.com/physics/FresnelEquations.html Eq(8),i.e., electric transmittance

	//wrong? return  (Cos > 0) ? m_yita * m_yita * Cos / (Cos + 2 * sqrtf(m_yita * m_yita - 1 + Cos * Cos)) : 0;
	return  (Cos > 0) ? 2 * Cos / (Cos + sqrtf(m_yita * m_yita - 1 + Cos * Cos)) : 0;
}

void CPRTView::OnDrawVisRatio()
{
	if(m_bLoadedVisibs)
	{
		m_bDrawVisRatio = !m_bDrawVisRatio;
		ChangeDrawElements();
	}
	else
	{
		printf("!m_bLoadedVisibs\n");
	}
	
}

Vec3 CPRTView::Rd(int xiIdx, int xoIdx) //symmetric matrix, but symmetry is not utilized. input 2 verts' index, ouput the float diffuse reflectance
{
	float r = Distance(m_accessObj.m_pModel->vpVertices[xiIdx + 1], m_accessObj.m_pModel->vpVertices[xoIdx + 1]);

	Vec3 dr, dv, fRd, zero = Vec3(0,0,0);
	
	dr = SQRTF(DP(m_zr, m_zr) + r * r);
	dv = SQRTF(DP(m_zv, m_zv) + r * r);

	fRd = DP(m_alphaPrime / (4.f * PI) , (	DD(DP(m_zr, m_sigmaTr + 1.f / dr, EXPF(DP(- m_sigmaTr, dr))), DP(dr, dr)) +
											DD(DP(m_zv, m_sigmaTr + 1.f / dv, EXPF(DP(- m_sigmaTr, dv))), DP(dv, dv)) ));

	//assert((fRd[0] >= 0)&& (fRd[1] >= 0)&& (fRd[2] >= 0));
	return fRd;
}

Vec3 CPRTView::Rd(float r)
{
	Vec3 dr, dv, fRd, zero = Vec3(0,0,0);

	dr = SQRTF(DP(m_zr, m_zr) + r * r);
	dv = SQRTF(DP(m_zv, m_zv) + r * r);

	fRd = DP(m_alphaPrime / (4.f * PI) , (	DD(DP(m_zr, m_sigmaTr + 1.f / dr, EXPF(DP(- m_sigmaTr, dr))), DP(dr, dr)) +
		DD(DP(m_zv, m_sigmaTr + 1.f / dv, EXPF(DP(- m_sigmaTr, dv))), DP(dv, dv)) ));

	//assert((fRd[0] >= 0)&& (fRd[1] >= 0)&& (fRd[2] >= 0));
	return fRd;
}

//find current light in current light rotation, store in m_curLightCoefs
//plan1(simple one):
//cubemap pre-SimpleDownSample(m_CubeMap, m_curLightCoefs);		//to save dynamic memcpy, m_curLightCoefs is also used as curlightCube at sampling phase.
//	for each side, i, j
//		side,i,j -> w', is 6*32*32
//		w = w' * EnvMat.inverse, get orig direction w;
//		get w's orig color: color = LightDir2Color(w)
//	//now we get a new lightmpa, currentLightCube[6*32*32]
//
//plan2(blur one):
//	for each side, i, j  -> w', is 6*256*256
//		w = w' * EnvMat.inverse
//		w -> cubeIndx[1-16]. //the cube should be pre-mend-edged!!
//		color = average(cubeIdx[1-16])
//get a new 6*32*32 currentLightCube
void CPRTView::CalcCurrentLightCube()
{
	Vec3 curDir = Vec3(0,0,0);
	Vec3 origDir = Vec3(0,0,0);
	Vec3 tmpDir = Vec3(0,0,0);
	float solidAngle = 1.f;
	for(int side = 0; side < 6; ++side)
	{
		for(int offset = 0; offset < m_cubeRes * m_cubeRes; ++offset)
		{
			curDir = m_cubeMap.Offset2Dir(side, offset, m_cubeRes, solidAngle);
			//Orig * EnvMat = Cur ==>   Orig = Cur * EnvMat.Inv
			origDir = VecMultMat4Inv(&curDir, &g_envTransform);
			m_curLightCoefs[side * m_cubeRes * m_cubeRes + offset] = *(m_cubeMap.Dir2NearestColor(origDir)) * solidAngle * m_hdrCoef;
		}
	}

//	//test m_curLightCoefs: passed
//	if(m_bLBDown)
//	{
//		for(int side = 0; side < 6; side++)
//		{
//			CString sss = "CurLightCoef";
//			char strSide[2];
//			_itoa(side, strSide, 10);
//			sss = sss + strSide + ".pfm";
//			m_cubeMap.WritePFMRaw(sss, &m_curLightCoefs[side * m_cubeRes * m_cubeRes], m_cubeRes, m_cubeRes);
//		}
//	}
}

//calls it only when changing light; if only change view, then no need call it.
void CPRTView::TransedRadiance()
{
	if(((!m_bLoadedTdCoefs) && (!m_bLoadedT1Coefs)) || (!m_bLoadedCubeMap)) //haven't loaded any coefs
		return;
	
	CalcCurrentLightCube(); //now m_curLightCoefs contains 6*32*32 CPoint3Ds

	for(int side = 0; side < 6; ++side)
	{
		m_wavelet.Haar2D(&m_curLightCoefs[side * m_cubeRes * m_cubeRes], m_cubeRes, m_cubeRes);//also used as curlightCube at sampling phase.
	}
}

void CPRTView::CalcColor()
{
	if(((!m_bLoadedTdCoefs) && (!m_bLoadedT1Coefs)) || (!m_bLoadedCubeMap)) //haven't loaded any coefs
		return;

	float Cos = 0;
	m_accessObj.m_pModel->vpColors[0] = Vec3(0,0,0);

	Vec3 eye = m_eye; //can't directly feed m_eye in below function!
	Vec3 eyeInModelLocal = VecMultMat4Inv(&eye, &g_modelTransform);	//eye * model.inv

	float hk = 0;
	Vec3* pVert = &m_accessObj.m_pModel->vpVertices[0];
	Vec3* pNorm = &m_accessObj.m_pModel->vpVertexNormals[0];
	Vec3* pColor = &m_accessObj.m_pModel->vpColors[0];
	int sideHG = 0, offsetHG = 0;
	int T1Idx = 0;
	Vec3 Transport;//can be any transport

	for(unsigned int xoIdx = 0; xoIdx < m_accessObj.m_pModel->nVertices; ++xoIdx)
	{
		++pVert;
		++pNorm;
		++pColor;
		Transport = Vec3(0,0,0);
		Vec3 viewLocal = Normalize(eyeInModelLocal - *pVert);

		if(m_bDrawMS)
		{
			for(unsigned int i = 0; i < m_useCoefNum; ++i)//note: if useCoef != T1coef, then T1Coef must be sorted first!!!
			{
				if(!_DiffuseE)
					Transport += DP(m_curLightCoefs[m_accessObj.m_pModel->vpTdCoefIdx[xoIdx * m_accessObj.m_pModel->nTdCoefNum + i]], 
					m_accessObj.m_pModel->vpTdCoefs[xoIdx * m_accessObj.m_pModel->nTdCoefNum + i] * m_MSWeight);
				else
					Transport += m_curLightCoefs[m_accessObj.m_pModel->vpECoefIdx[xoIdx * m_accessObj.m_pModel->nECoefNum + i]] * 
					m_accessObj.m_pModel->vpECoefs[xoIdx * m_accessObj.m_pModel->nECoefNum + i] * m_MSWeight;
			}
		}
		if(m_bDrawSS)
		{
			Vec3 NormNew = VecMultMat4(pNorm, &g_modelTransform);
			offsetHG = m_cubeMap.Dir2Offset(NormNew, m_HGres, sideHG);//normal's new direction
			for(int k = 0; k < m_usePhaseTerm; ++k)
			{
				Vec3 TL(0,0,0);
				for(unsigned int useCoefIdx = 0; useCoefIdx < m_useCoefNum; ++useCoefIdx)//note: if useCoef != T1coef, then T1Coef must be sorted first!!!
				{
					T1Idx = xoIdx * m_phaseSVDterm * m_T1CoefNum + k * m_T1CoefNum + useCoefIdx;//can't ++T1Idx, since m_T1CoefNum maynot ==m_useCoefNum!!!
					TL += DP(m_curLightCoefs[m_accessObj.m_pModel->vpT1CoefIdx[T1Idx]], m_accessObj.m_pModel->vpT1Coefs[T1Idx] * m_SSWeight);
				}
				hk = m_pH[k *  6 * m_HGres * m_HGres + sideHG * m_HGres * m_HGres + offsetHG];
				Transport += TL * hk;
			}
		}

		m_accessObj.m_pModel->vpTransedRadiance[xoIdx] = Transport;
		if(_Fwo1)
		{
			*pColor = m_accessObj.m_pModel->vpTransedRadiance[xoIdx] * m_colorCoef / PI;
		}
		else
		{
			Cos = max(0.f, Dot(*pNorm, viewLocal));//normLocal dot eyeLocal
			*pColor = m_accessObj.m_pModel->vpTransedRadiance[xoIdx] * m_colorCoef * FresnelT(Cos) / PI;
		}
		
		if(m_bDrawSS && _Spec)
		{
			float CosSpec = Dot(*pNorm, viewLocal);
			if(CosSpec > Epsilon)
			{
				Vec3 reflectLocal = *pNorm * 2.f * Dot(*pNorm, viewLocal) - viewLocal;
				Vec3 lightOrig = VecMultMat4Inv(&reflectLocal, &g_envTransform);
				*pColor += *(m_cubeMap.Dir2NearestColor(lightOrig)) * FresnelR(CosSpec) * m_specCoef * m_hdrCoef * m_colorCoef;
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//if(((!m_bLoadedTdCoefs) && (!m_bLoadedT1Coefs)) || (!m_bLoadedCubeMap)) //haven't loaded any coefs
	//	return;
	//for(unsigned int xoIdx = 0; xoIdx < m_accessObj.m_pModel->nVertices; ++xoIdx)
	//{
	//	Cos = max(0.f, Dot(m_accessObj.m_pModel->vpVertexNormals[xoIdx + 1], Normalize(eyeInModelLocal - m_accessObj.m_pModel->vpVertices[xoIdx + 1])));	//xo.norm dot(xo->eye)

	//	if(_Fwo1)
	//		fresnelT = 1 / PI;
	//	else
	//		fresnelT = FresnelT(Cos) / PI;

	//	m_accessObj.m_pModel->vpColors[xoIdx + 1] = m_accessObj.m_pModel->vpTransedRadiance[xoIdx] * fresnelT * m_colorCoef;
	//}
}

//tone brightness
BOOL CPRTView::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
	if(m_bLoadedCubeMap)
	{
		if (m_bLBDown)	//light
		{
			if(zDelta > 0)//zoomIn
				m_hdrCoef *= 1.25f;
			else if(zDelta < 0)
				m_hdrCoef *= 0.8f;	
			printf("m_hdrCoef=%f\n", m_hdrCoef);
		}
		else if (m_bRBDown)	//specular
		{
			if(zDelta > 0)//zoomIn
				m_specCoef *= 1.25f;
			else if(zDelta < 0)
				m_specCoef *= 0.8f;	
			printf("m_specCoef=%f\n", m_specCoef);
		}
		else	//light+mesh, color
		{
			if(zDelta > 0)//zoomIn
				m_colorCoef *= 1.25f;
			else if(zDelta < 0)
				m_colorCoef *= 0.8f;
			printf("m_colorCoef=%f\n", m_colorCoef);
		}
	}
	return CView::OnMouseWheel(nFlags, zDelta, pt);
}

void CPRTView::DrawCube(float cubeSize)
{
	glEnable(GL_TEXTURE_CUBE_MAP_ARB);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

	float fSize = cubeSize / 2.f;
	glBegin(GL_QUADS);

	//right face
	glTexCoord3f(1.0f, -1.0f, -1.0f);
	glVertex3f(fSize, -fSize, -fSize);			
	glTexCoord3f(1.0f, -1.0f, 1.0f);
	glVertex3f(fSize, -fSize, fSize);			
	glTexCoord3f(1.0f, 1.0f, 1.0f);
	glVertex3f(fSize, fSize, fSize);			
	glTexCoord3f(1.0f, 1.0f, -1.0f);
	glVertex3f(fSize, fSize, -fSize);

	//left face 
	glTexCoord3f(-1.0f, -1.0f, 1.0f);
	glVertex3f(-fSize, -fSize, fSize);			
	glTexCoord3f(-1.0f, -1.0f, -1.0f);
	glVertex3f(-fSize, -fSize, -fSize);			
	glTexCoord3f(-1.0f, 1.0f, -1.0f);
	glVertex3f(-fSize, fSize, -fSize);			
	glTexCoord3f(-1.0f, 1.0f, 1.0f);
	glVertex3f(-fSize, fSize, fSize);

	//top face 
	glTexCoord3f(-1.0f, 1.0f, -1.0f);
	glVertex3f(-fSize, fSize, -fSize);			
	glTexCoord3f(1.0f, 1.0f, -1.0f);
	glVertex3f(fSize, fSize, -fSize);
	glTexCoord3f(1.0f, 1.0f, 1.0f);
	glVertex3f(fSize, fSize, fSize);			
	glTexCoord3f(-1.0f, 1.0f, 1.0f);
	glVertex3f(-fSize, fSize, fSize);			

	//bottom face 
	glTexCoord3f(-1.0f, -1.0f, 1.0f);
	glVertex3f(-fSize, -fSize, fSize);			
	glTexCoord3f(1.0f, -1.0f, 1.0f);
	glVertex3f(fSize, -fSize, fSize);			
	glTexCoord3f(1.0f, -1.0f, -1.0f);
	glVertex3f(fSize, -fSize, -fSize);			
	glTexCoord3f(-1.0f, -1.0f, -1.0f);
	glVertex3f(-fSize, -fSize, -fSize);

	//back face
	glTexCoord3f(-1.0f, 1.0f, 1.0f);
	glVertex3f(-fSize, fSize, fSize);			
	glTexCoord3f(1.0f, 1.0f, 1.0f);
	glVertex3f(fSize, fSize, fSize);
	glTexCoord3f(1.0f, -1.0f, 1.0f);
	glVertex3f(fSize, -fSize, fSize);			
	glTexCoord3f(-1.0f, -1.0f, 1.0f);
	glVertex3f(-fSize, -fSize, fSize);			

	//front face
	glTexCoord3f(-1.0f, -1.0f, -1.0f);
	glVertex3f(-fSize, -fSize, -fSize);			
	glTexCoord3f(1.0f, -1.0f, -1.0f);
	glVertex3f(fSize, -fSize, -fSize);			
	glTexCoord3f(1.0f, 1.0f, -1.0f);
	glVertex3f(fSize, fSize, -fSize);			
	glTexCoord3f(-1.0f, 1.0f, -1.0f);
	glVertex3f(-fSize, fSize, -fSize);			

	glEnd();
	glDisable(GL_TEXTURE_CUBE_MAP_ARB);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);//GL_MODULATE);//return to model set
}

void CPRTView::OnInitialUpdate()
{
	GetParent()->ShowWindow(SW_SHOWMAXIMIZED);
	CView::OnInitialUpdate();
}

void CPRTView::InitCubeMap()
{
	glGenTextures(1, &m_cubeTex);
	glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, m_cubeTex);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);		
	glTexParameteri(GL_TEXTURE_CUBE_MAP_ARB, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);		
	for (int side = 0; side < 6; ++side) 
	{
		//glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT + side, 0, GL_RGB, m_cubeRes, m_cubeRes, 0, GL_RGB, GL_FLOAT, m_cubeMap.m_pDownCube + side * m_cubeRes * m_cubeRes);
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT + side, 0, GL_RGB, 256, 256, 0, GL_RGB, GL_FLOAT, m_cubeMap.m_pCube + side * 256 * 256);
	}
}
			
void CPRTView::OnOpenCubeMap()
{
	char szFilter[] = "pfm Files (*.pfm)|*.pfm|All Files (*.*)|*.*||";

	CFileDialog openDlg(TRUE,NULL,
		NULL,
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		szFilter,
		this);
	CString szFilepath;

	if(openDlg.DoModal() == IDOK)
	{
		szFilepath = openDlg.GetPathName();

		if(m_cubeMap.LoadPFM((char*)(LPCSTR)szFilepath))
		{
			InitCubeMap();
			m_bLoadedCubeMap = true;
			
			if(m_bLoadedTdCoefs || m_bLoadedE0T0)
				m_bDrawMS = true;
			if(m_bLoadedT1Coefs)
				m_bDrawSS = true;

			ChangeDrawElements();
			TransedRadiance();
			CalcColor();
		}
		////test passed
		//for(int side = 0; side < 6; ++side)
		//{
		//	for(int offset = 0; offset < m_cubeRes * m_cubeRes; ++offset)
		//	{
		//		Vec3 dir = m_cubeMap.Offset2Dir(side, offset, m_cubeRes);
		//		int j = m_cubeMap.Dir2Offset(dir, m_cubeRes, side);
		//		assert (offset == j);
		//	}
		//}
	}
}

void CPRTView::OnUpdateEditDrawNormal(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_bDrawNormal);
}

void CPRTView::OnUpdateEditDrawNormalMap(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_bDrawNormalMap);
}

void CPRTView::OnUpdateEditDrawVisRatio(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_bDrawVisRatio);
}

void CPRTView::OnEditDrawLight()
{
	m_bDrawLight = !m_bDrawLight;

	if(m_bDrawLight)
	{
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
	}
	else
	{
		glDisable(GL_LIGHTING);
		glDisable(GL_LIGHT0);
	}
	TransedRadiance();

	Invalidate();
}

void CPRTView::OnUpdateEditDrawLight(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_bDrawLight);
}

void CPRTView::OnDiffuseE()
{
	_DiffuseE = !_DiffuseE;
	TransedRadiance();
	CalcColor();
	Invalidate();
}

void CPRTView::OnFwi1()
{
	_Fwi1 = !_Fwi1;
	TransedRadiance();
	CalcColor();
	Invalidate();
}

void CPRTView::OnFwo1()
{
	_Fwo1 = !_Fwo1;
	TransedRadiance();
	CalcColor();
	Invalidate();
}

void CPRTView::OnUpdateDiffuseE(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(_DiffuseE);
}

void CPRTView::OnUpdateFwi1(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(_Fwi1);
}

void CPRTView::OnUpdateFwo1(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(_Fwo1);
}

void CPRTView::OnUsecoefnum4()
{
	m_useCoefNum = 4;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUsecoefnum8()
{
	m_useCoefNum = 8;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUsecoefnum16()
{
	m_useCoefNum = 16;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUseCoefNum32()
{
	m_useCoefNum = 32;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUsecoefnum64()
{
	m_useCoefNum = 64;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUsecoefnum96()
{
	m_useCoefNum = 96;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUsecoefnum128()
{
	m_useCoefNum = 128;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUsecoefnum256()
{	
	m_useCoefNum = 256;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateUsecoefnum4(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 4);
}

void CPRTView::OnUpdateUsecoefnum8(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 8);
}

void CPRTView::OnUpdateUsecoefnum16(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 16);

}

void CPRTView::OnUpdateUsecoefnum32(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 32);
}

void CPRTView::OnUpdateUsecoefnum64(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 64);
}

void CPRTView::OnUpdateUsecoefnum96(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 96);

}

void CPRTView::OnUpdateUsecoefnum128(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 128);

}

void CPRTView::OnUpdateUsecoefnum256(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_useCoefNum == 256);

}

////////////////////////////////////////////////////////////////////////// SSIso

//return sampleNum=16 intrude distances from verts, whose sampling path depth is dm. intrudes should have sampleNum elements!!!
void CPRTView::SSSampleIntrude(float* intrudes, float* pdfs, int sampleNum, float dm)
{
	assert(intrudes && (sampleNum > 0) && (dm > 0));

	if(_MC)
	{
		float lamda = 1.f - expf(- m_sigmaTLumi * dm);
		for(int i = 0; i < sampleNum; ++i)
		{
			float ksi = (i + 0.5f) / (float)sampleNum;		//NOTE "+" since i starts from 0!
			intrudes[i] = - logf(1 - lamda * ksi) / m_sigmaTLumi;
			pdfs[i] = m_sigmaTLumi * expf(-m_sigmaTLumi * intrudes[i]) / lamda;
		}
	}
	else
	{
		for(int i = 0; i < sampleNum; ++i)
		{
			intrudes[i] = dm * (i + 0.5f) / (float)sampleNum;
			pdfs[i] = 1.f / sampleNum;
		}
	}
	////test: assert sum(pdf*s) = 1, not passed
	//float* pdf = new float[sampleNum];	//gama
	//for(int i = 0; i < sampleNum; ++i)
	//{
	//	pdf[i] = sigmaTLumi * expf(- sigmaTLumi * intrudes[i]) / lamda;
	//}

	//float sum = 0.f;
	//for(int i = 0; i < sampleNum; ++i)
	//{
	//	sum += pdf[i] * intrudes[i];
	//}
	//assert(fabs(sum - 1.f) < 1.0e-5);
}

void CPRTView::SubsurfLookatVBOs()
{
	// Get Pointers To The GL Functions
	glGenBuffersARB = (PFNGLGENBUFFERSARBPROC) wglGetProcAddress("glGenBuffersARB");
	glBindBufferARB = (PFNGLBINDBUFFERARBPROC) wglGetProcAddress("glBindBufferARB");
	glBufferDataARB = (PFNGLBUFFERDATAARBPROC) wglGetProcAddress("glBufferDataARB");
	glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC) wglGetProcAddress("glDeleteBuffersARB");

	Vec3* pColors = new Vec3[m_accessObj.m_pModel->nVertices + 1];
	for(unsigned int i = 0; i <= m_accessObj.m_pModel->nVertices; ++i)
	{
		pColors[i] = (m_accessObj.m_pModel->vpVertexNormals[i] + 1) * 0.5f; //-1,1 -> 0,1
	}

	glEnableClientState( GL_VERTEX_ARRAY );						// Enable Vertex Arrays
	glEnableClientState(GL_COLOR_ARRAY);
	glDisableClientState(GL_NORMAL_ARRAY);

	// Generate And Bind The Vertex Buffer
	glGenBuffersARB( 1, &m_nVBOVertices );					// Get A Valid Name
	glBindBufferARB( GL_ARRAY_BUFFER_ARB, m_nVBOVertices );			// Bind The Buffer
	glBufferDataARB( GL_ARRAY_BUFFER_ARB, sizeof(Vec3) * (m_accessObj.m_pModel->nVertices + 1), m_accessObj.m_pModel->vpVertices, GL_STATIC_DRAW_ARB );
	glVertexPointer( 3, GL_FLOAT, 0, (char *) NULL );		// Set The Vertex Pointer To The Vertex Buffer

	glGenBuffersARB( 1, &m_nVBOColors );	
	glBindBufferARB( GL_ARRAY_BUFFER_ARB, m_nVBOColors );			// Bind The Buffer
	glBufferDataARB(GL_ARRAY_BUFFER_ARB,  sizeof(Vec3) * (m_accessObj.m_pModel->nVertices + 1), pColors, GL_STATIC_DRAW_ARB);
	glColorPointer(3, GL_FLOAT, 0, (char *) NULL);
	delete[] pColors;	pColors = NULL;
}

//for each vert, for each xp, calc visib2, accumu to T1, save it. also save subsurf vis ratio(svr)
void CPRTView::OnComputeSaveT1()
{
	if((!m_bLoadedObj) || (!m_bLoadedDm))
	{
		printf("!m_bLoadedObj || (!m_bLoadedDm)\n  ");
		return;
	}
	CString fnT1C = m_filenameNoSuffix + ".T1C";
	FILE* fT1C = NULL;
	if((fT1C = fopen(((char*)(LPCSTR)fnT1C), "wb")) == NULL)
	{
		printf("failed open writing T1C \n ");
		return;
	}
	//no longer svr
	const int nHGsize = 6 * m_HGres * m_HGres;
	vector<float>pG(m_phaseSVDterm * n6k, 1.f);
	if(!_HG1)
	{
		//HG16g-25t4.hgG
		CString fHgGn;
		if(fabs(m_g - 0.25f) < Epsilon)
			fHgGn = "HG16g25t32.hgG";
		else if(fabs(m_g - (-0.25f)) < Epsilon)
			fHgGn = "HG16g-25t32.hgG";
		else if(fabs(m_g - 0.4f) < Epsilon)
			fHgGn = "HG16g40t32.hgG";
		else if(fabs(m_g - (-0.4f)) < Epsilon)
			fHgGn = "HG16g-40t32.hgG";
		else if(fabs(m_g - 0.9f) < Epsilon)
			fHgGn = "HG16g90t32.hgG";
		else if(fabs(m_g - (-0.90f)) < Epsilon)
			fHgGn = "HG16g-90t32.hgG";
		else if(fabs(m_g - 0) < Epsilon)
			fHgGn = "HG16g0t32.hgG";

		FILE* fHgG;
		if((fHgG = fopen(((char*)(LPCSTR)fHgGn), "rb")) == NULL)
		{
			printf("failed open reading .hgG.\n ");
			return;
		}
		size_t n = fread(&pG[0], sizeof(float), m_phaseSVDterm * nHGsize, fHgG);	//may not read them all
		assert(n == (size_t)(nHGsize * m_phaseSVDterm));
		//size_t n = fread(&pG[0], sizeof(float), m_phaseSVDterm * n6k, fHgG);	//may not read them all
		//assert(n == (size_t)(n6k * m_phaseSVDterm));
		fclose(fHgG);
		printf("Gk loaded\n");
	}
	
	std::cout<<"m_SSSampleNum: "<<m_SSSampleNum<<", m_cubeRes: "<<m_cubeRes<<", m_g: "<<m_g<<endl;

	printf("start compute and save T1 Coefs...\n ");
	DWORD dwTmTtlSrt;
	DWORD dwTmTtlEnd;
	dwTmTtlSrt = GetTickCount();

	Vec3* pVert = &m_accessObj.m_pModel->vpVertices[0];
	Vec3* pNorm = &m_accessObj.m_pModel->vpVertexNormals[0];
	Vec3* pDm =  &m_accessObj.m_pModel->vpDm[0];
	Vec3 VertXp;

	//sample distances. MC importance sampling: 1/N * sum(f(xp) / pdf(xp))
	vector<float>intrudes(m_SSSampleNum);
	vector<float>pdfs(m_SSSampleNum);

	vector<Vec3>pOneT1(n6k, Vec3(0,0,0));	//note the init is important!!
	vector<byte>pSSVisOneVert(n6k, 0);
	vector<float>pSpOneVert(n6k, 0.f);
	vector<Vec3>pNiOneVert(n6k);
	vector<Vec3> pOneT1Loss(m_T1CoefNum);
	vector<unsigned int> pOneT1IdxLoss(m_T1CoefNum);
	//vector<Vec3>pOneT1Haared(n6k);

	SubsurfLookatInitGL();

	for (unsigned int vIdx = 0; vIdx < m_accessObj.m_pModel->nVertices; ++vIdx)
	{ 
		++pVert; //obj index starts from 1
		++pNorm;
		++pDm;
		SSSampleIntrude(&intrudes[0], &pdfs[0], m_SSSampleNum, pDm->x);	//Dm.x = y = z
		
		for(int p = 0; p < m_SSSampleNum; ++p)
		{
			VertXp = *pVert - *pNorm * intrudes[p]; //intrude to xp
			SubsurfLookat(&VertXp, &pSSVisOneVert[0], &pSpOneVert[0], &pNiOneVert[0]);	//get n6k vis,sp,Ni
			SubsurfBlend(&pOneT1[0], &pSSVisOneVert[0], &pSpOneVert[0], &pNiOneVert[0], &intrudes[p], &pdfs[p]);	 //blend above onto oneT1[n6k]
		}
		//blend Gk and Haar it to T1k
		float* pGk = &pG[0];
		for(int k = 0; k < m_phaseSVDterm; ++k)
		{
			Vec3* pT1 = &pOneT1[0];
			int multiple = m_cubeRes / m_HGres;
			for(int side = 0; side < 6; ++side)
				for(int row = 0; row < m_cubeRes; ++row)
					for(int col = 0; col < m_cubeRes; ++col)
					{
						pGk = &pG[k * 6 * m_HGres * m_HGres + side * m_HGres * m_HGres + (row/multiple) * m_HGres + (col/multiple)];//wi->wi' approx
						*pT1 = DP(*pT1, m_sigmaS) * (*pGk) / (float)m_SSSampleNum;
						++pT1;
					}
			//int sideHG, offsetHG;
			//for(int side = 0; side < 6; ++side)
			//	for(int offset = 0; offset < n1k; ++offset)
			//	{
			//		Vec3 tmpDir = m_cubeMap.Offset2Dir(side, offset, m_cubeRes);//
			//		offsetHG = m_cubeMap.Dir2Offset(tmpDir, m_HGres, sideHG);
			//		*pGk = pG[k * 6 * m_HGres * m_HGres + side * m_HGres * m_HGres + offsetHG];
			//		*pT1 = DP(*pT1, m_sigmaS) * (*pGk) / (float)m_SSSampleNum;
			//		++pT1;
			//	}

			//for(int in6k = 0; in6k < n6k; ++in6k)
			//{
			//	*pT1 = DP(*pT1, m_sigmaS) * (*pGk) / (float)m_SSSampleNum;
			//	++pT1;
			//	++pGk;
			//}

			//vector<Vec3>test(pOneT1);
			//vector<Vec3>test2(pOneT1);
			//for(int side = 0; side < 6; ++side)
			//{	
			//	m_wavelet.Haar2D(&pOneT1[side * n1k], m_cubeRes, m_cubeRes);
			//	m_wavelet.haar2d(&test[side * n1k], &test2[side * n1k], m_cubeRes);
			//}
			//for(int i = 0; i < n6k; ++i)
			//{
			//	Vec3 heh = test2[i] - pOneT1[i];
			//	assert(heh.x < Epsilon);
			//}
			for(int side = 0; side < 6; ++side)
			{
				m_wavelet.Haar2D(&pOneT1[side * n1k], m_cubeRes, m_cubeRes);
				//wrong. after this line, pOneT1 !=pOneT1Haared. 
				//m_wavelet.haar2d(&pOneT1[side * n1k], &pOneT1Haared[side * n1k], m_cubeRes);
			}
			KeepLoss(&pOneT1[0], n6k, m_T1CoefNum, &pOneT1Loss[0], &pOneT1IdxLoss[0]);
			//KeepLoss(&pOneT1Haared[0], n6k, m_T1CoefNum, &pOneT1Loss[0], &pOneT1IdxLoss[0]);

			//T1C format: each vert, each k, m_T1CoefNum's T1Coef and T1CoefIdx
			size_t n = fwrite(&pOneT1Loss[0], sizeof(Vec3), m_T1CoefNum, fT1C);
			assert(n == size_t(m_T1CoefNum));
			n = fwrite(&pOneT1IdxLoss[0], sizeof(unsigned int), m_T1CoefNum, fT1C);
			assert(n == size_t(m_T1CoefNum));
		}
		if(vIdx % 100 == 0)
		{
			dwTmTtlEnd = GetTickCount();
			std::cout<<"T1k coefs of vert "<<vIdx<<" of "<< m_accessObj.m_pModel->nVertices<<" vertices finished, time: "<< (dwTmTtlEnd - dwTmTtlSrt) / 1000<<" \n";
		}
	}
	std::cout<<"Finish T1k coefs ! \n";

	fclose(fT1C);

	if(m_nVBOVertices || m_nVBOColors)
	{
		unsigned int nBuffers[2] = { m_nVBOVertices, m_nVBOColors };
		glDeleteBuffersARB( 2, nBuffers );						// Free The Memory
	}
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glDisable(GL_STENCIL_TEST);
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	InitGL();

	CString T1CName = m_filenameNoSuffix + ".T1C";
	if(m_accessObj.LoadT1Coefs((char*)(LPCSTR)T1CName))	
	{
		m_bLoadedT1Coefs = true;
	}
	if(m_bLoadedT1Coefs && m_bLoadedCubeMap)
		m_bDrawSS = true;
	ChangeDrawElements();
}

void CPRTView::SubsurfLookatInitGL()
{
	//reset GL for subsurfVisib use	
	glDrawBuffer(GL_BACK);
	glReadBuffer(GL_BACK);

	glViewport(0, 0, m_cubeRes, m_cubeRes);
	glClearColor(0,0,0,0);

	glEnable(GL_DEPTH_TEST);
	glClearDepth(1.0);

	glEnable(GL_STENCIL_TEST);
	glClearStencil(0x0);
	glStencilFunc(GL_ALWAYS, 0x1, 0x1);
	glStencilOp (GL_INCR, GL_INCR, GL_INCR);

	//Reset The Projection Matrix
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluPerspective(90, 1, 0.001f, m_objBboxSize * 2);	//near:intrude[0] is minimal distance that should be covered in [near,far]. 
	//for m_bbox=10, dm=0.1 is suitable. For dm=0.1 case,intrude[0]=0.003. 
	//so for near, 0.001 is enough.far:m_objBboxSize * sqrtf(3)) is enough
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();

	//VBO
	// Get Pointers To The GL Functions
	glGenBuffersARB = (PFNGLGENBUFFERSARBPROC) wglGetProcAddress("glGenBuffersARB");
	glBindBufferARB = (PFNGLBINDBUFFERARBPROC) wglGetProcAddress("glBindBufferARB");
	glBufferDataARB = (PFNGLBUFFERDATAARBPROC) wglGetProcAddress("glBufferDataARB");
	glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC) wglGetProcAddress("glDeleteBuffersARB");

	Vec3* pColors = new Vec3[m_accessObj.m_pModel->nVertices + 1];
	for(unsigned int i = 0; i <= m_accessObj.m_pModel->nVertices; ++i)
	{
		pColors[i] = (m_accessObj.m_pModel->vpVertexNormals[i] + 1) * 0.5f; //-1,1 -> 0,1
	}

	glEnableClientState( GL_VERTEX_ARRAY );						// Enable Vertex Arrays
	glEnableClientState(GL_COLOR_ARRAY);
	glDisableClientState(GL_NORMAL_ARRAY);

	// Generate And Bind The Vertex Buffer
	glGenBuffersARB( 1, &m_nVBOVertices );					// Get A Valid Name
	glBindBufferARB( GL_ARRAY_BUFFER_ARB, m_nVBOVertices );			// Bind The Buffer
	glBufferDataARB( GL_ARRAY_BUFFER_ARB, sizeof(Vec3) * (m_accessObj.m_pModel->nVertices + 1), m_accessObj.m_pModel->vpVertices, GL_STATIC_DRAW_ARB );
	glVertexPointer( 3, GL_FLOAT, 0, (char *) NULL );		// Set The Vertex Pointer To The Vertex Buffer

	glGenBuffersARB( 1, &m_nVBOColors );	
	glBindBufferARB( GL_ARRAY_BUFFER_ARB, m_nVBOColors );			// Bind The Buffer
	glBufferDataARB(GL_ARRAY_BUFFER_ARB,  sizeof(Vec3) * (m_accessObj.m_pModel->nVertices + 1), pColors, GL_STATIC_DRAW_ARB);
	glColorPointer(3, GL_FLOAT, 0, (char *) NULL);
	delete[] pColors;	pColors = NULL;
}

//eye at pXp, lookat n6k dirs, to get vis,sp,ni, to accum to T1
void CPRTView::SubsurfLookat(Vec3* pXp, byte* pSSVisOneVert, float* pSpOneVert, Vec3* pNiOneVert)
{
	//sp'
	GLdouble spX, spY, spZ;
	GLdouble IdModel[16] = {1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1};
	GLdouble Proj[16];
	glGetDoublev(GL_PROJECTION_MATRIX, Proj);
	GLint viewport[16];
	glGetIntegerv(GL_VIEWPORT, viewport);

	Vec3 center = Vec3(0,0,0);
	Vec3 up = Vec3(0,0,0);
	for(int side = 0; side < 6; side++)
	{
		glClear(GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		m_cubeMap.EyeSide2CenterUp(pXp, side, &center, &up);
		gluLookAt(pXp->x, pXp->y, pXp->z,
			center.x, center.y, center.z,
			up.x, up.y, up.z);
		glDrawElements(GL_TRIANGLES, 3 * m_accessObj.m_pModel->nTriangles, GL_UNSIGNED_INT, &m_accessObj.m_pModel->TrianglesIndices[0]);
		glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, &pSSVisOneVert[side * n1k]); //subsurf visibs
		glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_DEPTH_COMPONENT, GL_FLOAT, &pSpOneVert[side * n1k]);
		glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_RGB, GL_FLOAT, &pNiOneVert[side * n1k]);
	}

	//Ni
	Vec3* pNi = &pNiOneVert[0];
	//Sp
	float* pSp = &pSpOneVert[0];
	for(int i = 0; i < n6k; ++i)
	{
		//Ni
		*pNi = (*pNi * 2.f) - 1.f;
		pNi->Normalize();
		++pNi;
		//Sp
		gluUnProject(GLdouble(i % m_cubeRes), GLdouble(i / m_cubeRes),  GLdouble(*pSp), IdModel, Proj, (GLint*)viewport, &spX, &spY, &spZ);
		*pSp = (float)-spZ;
		++pSp;
	}
	//side0 fliplr
	Fliplr(&pSpOneVert[0], m_cubeRes, m_cubeRes);
	Fliplr(&pNiOneVert[0], m_cubeRes, m_cubeRes);
	Fliplr(&pSSVisOneVert[0], m_cubeRes, m_cubeRes);
}

void	CPRTView::SubsurfBlend(Vec3* pOneT1, byte* pSSVisOneVert, float* pSpOneVert, Vec3* pNiOneVert, float* pIntrude, float* pPdf)
{
	float Cos;
	int curOffset = 0;
	//Vec3 Wi;
	float Sp1;
	Vec3* pT1 = pOneT1;
	byte* pVis = pSSVisOneVert;
	float* pSp = pSpOneVert;
	Vec3* pNi = pNiOneVert;
	for(int side = 0; side < 6; ++side)
		for(int offset = 0; offset < n1k; ++offset)
		{
			//Wi = m_cubeMap.Offset2Dir(side, offset, m_cubeRes);
			//curOffset = side * n1k + offset;
			if(*pVis == 1) //stencil==1: visible.
			{
				Cos = Dot(*pNi, m_cubeMap.Offset2Dir(side, offset, m_cubeRes));
				//Cos = Dot(*pNi, Wi);
				if(Cos > Epsilon)
				{
					Sp1 = pSpOneVert[curOffset] * (Cos / sqrtf(1 - (1 - Cos * Cos) / m_yita / m_yita));
					if(_Fwi1)
						*pT1 += EXPF(- m_sigmaT * (*pIntrude + Sp1)) / *pPdf;
					else
						*pT1 += EXPF(- m_sigmaT * (*pIntrude + Sp1)) / *pPdf * FresnelT(Cos);
				}
			}
			++curOffset;
			++pT1;
			++pVis;
			++pSp;
			++pNi;
		}
}

//input: Xp, side. output: stencil->pSSVis; depth->Sp; color->Ni(Norm xi).
//standing at pXp, which is below surface, lookAt 1 of 6 sides of resolution m_pModel's visibRes, 
//fill the 2nd visib map of pVert into subsurfvisibs. fill normals of intersected (interpolated) pixel-normals into Norm, fill depths into spPrime.
int	CPRTView::SubSurfVisibleLightSide(byte* pSSVisOneSide, float* pSpOneSide, Vec3* pNiOneSide, Vec3* pXp, int side, long int& debugXpOutSum)
{
	glClear(GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	Vec3 center = Vec3(0,0,0);
	Vec3 up = Vec3(0,0,0);
	m_cubeMap.EyeSide2CenterUp(pXp, side, &center, &up);
	gluLookAt(pXp->x, pXp->y, pXp->z,
		center.x, center.y, center.z,
		up.x, up.y, up.z);

	glDrawElements(GL_TRIANGLES, 3 * m_accessObj.m_pModel->nTriangles, GL_UNSIGNED_INT, &m_accessObj.m_pModel->TrianglesIndices[0]);
	//glCallList(m_displayListId);

	glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, pSSVisOneSide); //subsurf visibs
	glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_DEPTH_COMPONENT, GL_FLOAT, pSpOneSide);
	glReadPixels(0, 0, m_cubeRes, m_cubeRes, GL_RGB, GL_FLOAT, pNiOneSide);

	//count visRatio, normalize pNi
	int visCount = 0;
	GLubyte* pStencil = pSSVisOneSide;
	Vec3* pNi = pNiOneSide;
	for(int i = 0; i < m_cubeRes * m_cubeRes; ++i)
	{	
		*pNi = (*pNi * 2.f) - 1.f;
		pNi->Normalize();	//norm
		if(*pStencil == 1)//subsurfvisible
		{
			visCount++;
		}		
		else if(*pStencil == 0) //shouldn't happen!
		{
			debugXpOutSum++;
			//printf("sample == 0\n");
			//*pStencil = 1;	//modify it to invisible
		}
		//else //test passed
		//	assert((*pStencil > 1) && (*pStencil <= 255));	
		++pStencil;
		++pNi;
	}
	return visCount;	
}

void CPRTView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(m_bDrawSubsurfVisratio)
	{
		m_svrKeyDownIdx = (m_svrKeyDownIdx + 1) % m_SSSampleNum;
		printf("%dth subvisratio\n", m_svrKeyDownIdx);
	}
	
	if((m_bLoadedObj) && (nChar == 0x57))//VK_W))
	{
		m_fillMode = (m_fillMode + 1) % 2;	

		if(m_fillMode == 0)
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		else if(m_fillMode == 1)
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		
		printf("fill mode changed\n");
	}

	if((m_bLoadedTdCoefs) && (nChar == 0x4d))//VK_M))
	{
		m_bDrawMS = !m_bDrawMS;
		printf("m_bDrawMS = %d\n", m_bDrawMS);
	}
	if((m_bLoadedTdCoefs) && (nChar == VK_UP))
	{
		m_MSWeight *= 1.1f;
		printf("m_MSWeight = %f\n", m_MSWeight);
	}
	if((m_bLoadedTdCoefs) && (nChar == VK_DOWN))
	{
		m_MSWeight *= 0.9f;
		printf("m_MSWeight = %f\n", m_MSWeight);
	}

	if(m_bLoadedT1Coefs && (nChar == 0x53))//VK_S))
	{
		m_bDrawSS = !m_bDrawSS;
		printf("m_bDrawSS = %d\n", m_bDrawSS);
	}

	if(m_pECoefsTree && (nChar == 0x42) && GetKeyState(VK_CONTROL))//VK_B))
	{
		m_bDrawBBox = !m_bDrawBBox;
	}
	if(_Tex && (!m_textureImage.empty()) && (nChar == 0x54)) //VK_T
	{
		if(GetKeyState(VK_CONTROL) < 0) //decrease
		{
			m_texAlpha = unsigned char(max(10, min(255, m_texAlpha * 0.9f)));
		}
		else
		{
			m_texAlpha = unsigned char(max(10, min(255, m_texAlpha * 1.1f)));
		}
		printf("m_texAlpha = %d\n",m_texAlpha);
		for(int i = 0; i < m_texW * m_texH; ++i)
			m_textureImage[i * 4 + 3] = m_texAlpha;
	}
	ChangeDrawElements();
	TransedRadiance();
	CalcColor();

	Invalidate();
	return CView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CPRTView::OnDrawSubsurfVisRatio()
{	
	if(m_bLoadedSubsurfVisRatio)
	{
		m_bDrawSubsurfVisratio = !m_bDrawSubsurfVisratio;
		Invalidate();
	}
	else
	{
		printf("!m_bDrawSubsurfVisratio\n");
	}
}

void CPRTView::OnUpdateDrawSubsurfVisRatio(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_bDrawSubsurfVisratio);
}

//depth : using a ray tracer by shooting a ray along the negative normal direction and detecting the intersection. used by SSSample integration upper limit
void CPRTView::OnComputeSaveDm()
{
	printf("start compute save Dm...\n ");
	if((!m_bLoadedObj))
	{
		printf("!m_bLoadedObj\n ");
		return;
	}

	CString fnDm = m_filenameNoSuffix + ".Dm";
	FILE* f;
	if((f = fopen(((char*)(LPCSTR)fnDm), "wb")) == NULL)
	{
		printf("failed open fnDm \n ");
		return;
	}

	assert(m_accessObj.m_pModel);
	m_accessObj.m_pModel->vpDm.clear();
	m_accessObj.m_pModel->vpDm.resize(m_accessObj.m_pModel->nVertices + 1);

	glDrawBuffer(GL_BACK);
	glReadBuffer(GL_BACK);

	glViewport(0, 0, m_nWidth, m_nHeight);  //(0,0,1,1)won't work, will die ugly
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
	glEnable(GL_DEPTH_TEST);
	glClearDepth(1.0);

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	//Larger than the real range, so that verts on the bbox can be correctly handled
	float maxCoord = (m_objBboxSize * 2.f);
	//zNear, zFar 	The distances to the nearer and farther depth clipping planes. These distances are negative if the plane is to be behind the viewer. 
	glOrtho(-maxCoord, maxCoord, -maxCoord, maxCoord, 0, maxCoord);	

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

	Vec3* pV = &m_accessObj.m_pModel->vpVertices[1]; //starts from 1;
	Vec3* pNorm = &m_accessObj.m_pModel->vpVertexNormals[1];
	Vec3* pDm = &m_accessObj.m_pModel->vpDm[1];
	float depth = 0;
	Vec3* pVert = NULL;
	Vec3 vecX;
	GLubyte color;
	for(unsigned int vIdx = 0; vIdx < m_accessObj.m_pModel->nVertices; ++vIdx)
	{
		glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		vecX = Vec3(0.2f, 0.3f, 0.5f);
		vecX.Normalize();
		vecX = Cross(*pNorm, vecX);//center is in the viewport center, so up is random. but Up should not parellel norm
		vecX.Normalize();
		gluLookAt(pV->x - Epsilon * pNorm->x, pV->y - Epsilon * pNorm->y, pV->z - Epsilon * pNorm->z, 
			pV->x - pNorm->x, pV->y - pNorm->y, pV->z - pNorm->z, vecX.x, vecX.y, vecX.z); //so that Center - Eye = -norm direction

		glBegin(GL_TRIANGLES);
		for(unsigned int i = 0; i < m_accessObj.m_pModel->nTriangles; i++)
		{
			for(int j = 0; j < 3;j++)
			{
				pVert = &m_accessObj.m_pModel->vpVertices[(m_accessObj.m_pModel->pTriangles[i]).vindices[j]];
				glVertex3f(pVert->x, pVert->y, pVert->z);
			}
		}
		glEnd();
		glFlush();
		glReadPixels(m_nWidth/2, m_nHeight/2, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &depth);
		glReadPixels(m_nWidth/2, m_nHeight/2, 1, 1, GL_RED, GL_UNSIGNED_BYTE, &color);
		pDm->x = (color > 0) ? max(depth * maxCoord, 0) : 0;	//maxCoord * 2 is the Ortho size. queried depth of [0,1] should be scaled back by the ortho size
		pDm->y = pDm->x;
		pDm->z = pDm->x;
		
		++pDm;	
		++pV;
		++pNorm;
		
		if(vIdx % 100 == 0)
			printf("Dm of vert %d of %d vertices finished. \n",vIdx, m_accessObj.m_pModel->nVertices);
	}

	//dump Dm
	size_t n = fwrite(&m_accessObj.m_pModel->vpDm[0], sizeof(Vec3), m_accessObj.m_pModel->nVertices + 1, f);
	assert(n == m_accessObj.m_pModel->nVertices + 1);
	fclose(f);

	m_bLoadedDm = true;
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	InitGL();
	printf("compute save Dm finished \n ");
}

void CPRTView::OnDrawDm()
{
	m_bDrawDm = !m_bDrawDm;
	Invalidate();
}

void CPRTView::OnUpdateDrawDm(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_bDrawDm);
}

////////////////////////////////////////////////////////////////////////// 2-pass

//save .E, and also load into memory
void CPRTView::OnEditComputeSaveE()
{
	if((!m_bLoadedObj) || (!m_bLoadedVisibs))
	{
		printf("(!m_bLoadedObj) || !m_bLoadedVisibs \n ");
		return;
	}

	CString fnE = m_filenameNoSuffix + ".E";
	FILE* fE = NULL;
	if((fE = fopen(((char*)(LPCSTR)fnE), "wb")) == NULL)
	{
		printf("failed open fnE \n ");
		return;
	}

	//alloc Coefs in memory, no need to r/w memory
	m_accessObj.m_pModel->vpECoefs.clear();
	m_accessObj.m_pModel->vpECoefs.resize(m_accessObj.m_pModel->nVertices * m_ECoefNum);
	m_accessObj.m_pModel->vpECoefIdx.clear();
	m_accessObj.m_pModel->vpECoefIdx.resize(m_accessObj.m_pModel->nVertices * m_ECoefNum);

	int nVisPerside = m_cubeRes * m_cubeRes;
	float* OneE = new float[6 * nVisPerside];
	Vec3 curDir;
	Vec3* pNorm = NULL;
	byte* pInvis = &m_accessObj.m_pModel->vpVertInvisibs[0];
	float solidAngle = 1.f;
	float Cos = 0;
	for(unsigned int xiIdx = 0; xiIdx < m_accessObj.m_pModel->nVertices; ++xiIdx)
	{
		for(int side = 0; side < 6; ++side)
		{
			for(int offset = 0; offset < nVisPerside; ++offset)
			{
#ifdef StencilVis
				if(*pInvis != 0)
#else
				if(*pInvis == 255) //invisible
#endif
					OneE[side * nVisPerside + offset] = 0;
				else
				{
					pNorm = &m_accessObj.m_pModel->vpVertexNormals[xiIdx + 1];
					curDir = m_cubeMap.Offset2Dir(side, offset, m_cubeRes, solidAngle);
					Cos = max(Dot((*pNorm), curDir), 0);
					if(_Fwi1)
						OneE[side * nVisPerside + offset] = Cos;
					else
						OneE[side * nVisPerside + offset] = Cos * FresnelT(Cos);
				}
				++pInvis;
			}
			//wavelet E
			m_wavelet.Haar2D(OneE + side * nVisPerside, m_cubeRes, m_cubeRes);
		}
		//return into vpECoefs and vpECoefIdx
		KeepLoss(OneE, 6 * nVisPerside, m_ECoefNum, &m_accessObj.m_pModel->vpECoefs[xiIdx  * m_accessObj.m_pModel->nECoefNum], &m_accessObj.m_pModel->vpECoefIdx[xiIdx * m_accessObj.m_pModel->nECoefNum]);

		size_t n = fwrite(&m_accessObj.m_pModel->vpECoefs[xiIdx * m_accessObj.m_pModel->nECoefNum], sizeof(float), m_ECoefNum, fE);
		assert(n == size_t(m_ECoefNum));

		n = fwrite(&m_accessObj.m_pModel->vpECoefIdx[xiIdx * m_accessObj.m_pModel->nECoefNum], sizeof(unsigned int), m_ECoefNum, fE);
		assert(n == size_t(m_ECoefNum));

		if(xiIdx % 100 == 0)
			printf("E Coefs of vert %d of %d vertices finished.\n", xiIdx, m_accessObj.m_pModel->nVertices);
	}
	printf("E Coefs and Indices finished save.\n");
	fclose(fE);
}

//build m_tree only of Pv, Av. and Ev, which is ECoefNum.
void CPRTView::OnBuildTree()
{
	if(!m_bLoadedObj)
	{
		printf("(!m_bLoadedObj)\n ");
		return;
	}
	CString eName = m_filenameNoSuffix + ".E";
	if(!m_accessObj.LoadECoefs((char*)(LPCSTR)eName))	
	{	
		printf("failed LoadECoefs!\n ");
		return;
	}
	
	printf("start calc areas...\n");
	m_accessObj.CalcVertArea();

	m_pECoefsTree = new CKdTree(m_accessObj.m_pModel->nVertices, m_ECoefNum);
	for(unsigned int i = 0; i < m_accessObj.m_pModel->nVertices; ++i)
		m_pECoefsTree->pVIndices[i] = i + 1; //vpVertices starts from 1

	m_pECoefsTree->pP = NULL;
	m_pECoefsTree->pBox[0] = m_pECoefsTree->pBox[2] = m_pECoefsTree->pBox[4] = m_objBboxSize / 2.f;	//xMax, yMax, zMax
	m_pECoefsTree->pBox[1] = m_pECoefsTree->pBox[3] = m_pECoefsTree->pBox[5] = -m_objBboxSize / 2.f; //xMin, yMin, zMin
	m_pECoefsTree->depth = 0;
	
	float* pBufOneE = new float[n6k];

	printf("start building mesh kd-tree...\n");

	RecurAccumETree(m_pECoefsTree, pBufOneE);
	
	delete[] pBufOneE;
	printf("Build mesh kd-tree finished.\n");
	//can only debug small mesh. box passed.
	if(m_accessObj.m_pModel->nVertices <= 100)
		m_pECoefsTree->PrintInfo();
}

//use n6k pBufOneE to accum all pt's v[nVIndices]' ECoefs
void CPRTView::RecurAccumETree(CKdTree* pt, float* pBufOneE)
{
	for(unsigned int i = 0; i < pt->nVIndices; ++i)
	{
		memset(pBufOneE, 0, sizeof(float) * n6k);
		//Ev
		int vIdxFrom0 = pt->pVIndices[i] - 1;
		for(unsigned int j = 0; j < m_ECoefNum; ++j)
		{
			int EIdx = m_accessObj.m_pModel->vpECoefIdx[vIdxFrom0 * m_accessObj.m_pModel->nECoefNum + j];
			pBufOneE[EIdx] += m_accessObj.m_pModel->vpECoefs[vIdxFrom0 * m_accessObj.m_pModel->nECoefNum + j];
		}
		//Pv
		pt->Pv += m_accessObj.m_pModel->vpVertices[vIdxFrom0 + 1];
		//Av
		pt->Av += m_accessObj.m_pModel->vpVertAreas[vIdxFrom0];
	}
	KeepLoss(pBufOneE, n6k, m_ECoefNum, pt->pECoefs, pt->pECoefIdx);

	pt->Pv = pt->Pv / (float)pt->nVIndices;
	//bug###pt->Av /= (float)pt->nVIndices;

	//split
	if(pt->nVIndices > (unsigned int)m_leafSampleNum)
	{
		pt->pL = new CKdTree((pt->nVIndices + 1) / 2, m_ECoefNum);	//if pt->vecCnt is odd, say 5, then pL gets 1 more than pR, 3:2
		pt->pR = new CKdTree(pt->nVIndices / 2, m_ECoefNum);
		pt->pL->pP = pt;
		pt->pR->pP = pt;
		pt->pL->depth = pt->pR->depth = pt->depth + 1;

		//has alloced pt->pL and pR, now find nth(pt->VIds, DIM(pt->depth)), fill VIndices and Boxes of pL and pR
		KdNodeSplit(pt);

		//recursive
		RecurAccumETree(pt->pL, pBufOneE);
		RecurAccumETree(pt->pR, pBufOneE);
	}
	else	//leaf
	{
		pt->pL = pt->pR = NULL;	
	}
	//8 vert box test passed
}

//has alloced pt->pL and pR, now find nth(pt->VIds, DIM(pt->depth)), fill VIndices and Boxes of pL and pR
void CPRTView::KdNodeSplit(CKdTree* pt)
{
	std::vector<unsigned int> PIds(pt->nVIndices);
	for(unsigned int i = 0; i < pt->nVIndices; ++i)
		PIds[i] = pt->pVIndices[i];

	//below split pt's vindices into 2 parts, pL and pR. And meantime calc bbox for both.
	memcpy(pt->pL->pBox, pt->pBox, sizeof(float) * 6);
	memcpy(pt->pR->pBox, pt->pBox, sizeof(float) * 6);
	switch(pt->depth % 3)
	{
	case 0:
		std::nth_element(PIds.begin(), PIds.begin() + pt->pL->nVIndices, PIds.end(), xLess(m_accessObj.m_pModel->vpVertices));
		pt->pL->pBox[0] = pt->pR->pBox[1] = m_accessObj.m_pModel->vpVertices[PIds[pt->pL->nVIndices]].x;
		break;
	case 1:
		std::nth_element(PIds.begin(), PIds.begin() + pt->pL->nVIndices, PIds.end(), yLess(m_accessObj.m_pModel->vpVertices));
		pt->pL->pBox[2] = pt->pR->pBox[3] = m_accessObj.m_pModel->vpVertices[PIds[pt->pL->nVIndices]].y;
		break;
	case 2:
		std::nth_element(PIds.begin(), PIds.begin() + pt->pL->nVIndices, PIds.end(), zLess(m_accessObj.m_pModel->vpVertices));
		pt->pL->pBox[4] = pt->pR->pBox[5] = m_accessObj.m_pModel->vpVertices[PIds[pt->pL->nVIndices]].z;
		break;
	default:
		break;
	}

	for(unsigned int i = 0; i < pt->pL->nVIndices; ++i)//pL
	{
		pt->pL->pVIndices[i] = PIds[i];
	}
	for(unsigned int i = 0; i < pt->pR->nVIndices; ++i)//pR
	{
		pt->pR->pVIndices[i] = PIds[pt->pL->nVIndices + i];
	}	

	//need test
}

//2pass, compute E-kd tree, and compute Td, save to .Td2
void CPRTView::OnMSTrans2Pass()
{
	//repulsion(uint* sampleVertIndices); -> omit currently
	//ECoefsKdTree(KdTree* t) by bbox, its key is 6k waveles, save to .kd;
	//ECoefs(sampleVIndices, useENum), dump to .EC; -> now we don't sample(repultion retiling): we use vId, ECoef[nv][useENum]
	//Trans(t), save to .TdC;

	//alloc oneT[6*32*32]
	//for each xo in nv
	//	CalcT(oneT, xoIdx, tree, eps);

	if((!m_bLoadedObj) || (!m_pECoefsTree))
	{
		printf("(!m_bLoadedObj) || !m_pECoefsTree \n ");
		return;
	}

	CString fnTd = m_filenameNoSuffix + ".Td2";
	FILE* fTd = NULL;
	if((fTd = fopen(((char*)(LPCSTR)fnTd), "wb")) == NULL)
	{
		printf("failed open writing .Td2 \n ");
		return;
	}

	Vec3* pBufOneTd = new Vec3[n6k];
	Vec3* OneTdLoss = new Vec3[m_TdCoefNum];
	unsigned int* OneTdIdxLoss = new unsigned int[m_TdCoefNum];
	for(unsigned int xoIdx = 0; xoIdx < m_accessObj.m_pModel->nVertices; ++xoIdx)
	{
		memset(pBufOneTd, 0, sizeof(Vec3) * n6k); //can't place it into Recursive, or it will be constantly ZERO!!!! 

		RecurAccumTd(pBufOneTd, &m_accessObj.m_pModel->vpVertices[xoIdx + 1], m_pECoefsTree);

		KeepLoss(pBufOneTd, n6k, m_TdCoefNum, OneTdLoss, OneTdIdxLoss);

		size_t n = fwrite(OneTdLoss, sizeof(Vec3), m_TdCoefNum, fTd);
		assert(n == size_t(m_TdCoefNum));
		n = fwrite(OneTdIdxLoss, sizeof(unsigned int), m_TdCoefNum, fTd);
		assert(n == size_t(m_TdCoefNum));

		if(xoIdx % 100 == 0)
			printf("Td2 Coefs of vert %d of %d vertices finished.\n", xoIdx, m_accessObj.m_pModel->nVertices);
	}
	printf("Td2 Coefs and Indices finished save.\n");
	fclose(fTd);

	delete[] pBufOneTd;
	delete[] OneTdLoss;
	delete[] OneTdIdxLoss;
}

inline bool VInBox(Vec3* pV, float* pBox)
{
	return(	(pV->x <= pBox[0]) &&
		(pV->x >= pBox[1]) &&
		(pV->y <= pBox[2]) &&
		(pV->y >= pBox[3]) &&
		(pV->z <= pBox[4]) &&
		(pV->z >= pBox[5])	);
}

//accumulate Rd*E to Td, use pBuf as buf so to avoid frequent new/delete
void CPRTView::RecurAccumTd(Vec3* pBufOneTd, Vec3* pVert, CKdTree* pt)
{
	if(pt->pL)
	{
		if(!VInBox(pVert, pt->pBox))
		{
			float r = Distance(*pVert, pt->Pv);
			if(pt->Av / (r * r) < m_epsMSTdKd)	//distant voxel
			{
				Vec3 Rd1 = Rd(r);
				//accum
				for(unsigned int i = 0; i < m_ECoefNum; ++i)
					pBufOneTd[pt->pECoefIdx[i]] += Rd1 * pt->pECoefs[i]; 
				return;
			}
			else
			{
				RecurAccumTd(pBufOneTd, pVert, pt->pL);
				RecurAccumTd(pBufOneTd, pVert, pt->pR);
			}
		}
		else	//v in voxel
		{
			RecurAccumTd(pBufOneTd, pVert, pt->pL);
			RecurAccumTd(pBufOneTd, pVert, pt->pR);
		}
	}
	else //leaf
	{
		float r = Distance(*pVert, pt->Pv);
		Vec3 Rd1 = Rd(r);
		//accum
		for(unsigned int i = 0; i < m_ECoefNum; ++i)
			pBufOneTd[pt->pECoefIdx[i]] += Rd1 * pt->pECoefs[i];
	}
}
void CPRTView::OnLoadTd()
{
	//CString eName = m_filenameNoSuffix + ".E";
	//if(m_accessObj.LoadECoefs((char*)(LPCSTR)eName))
	//	;

	CString TdName = m_filenameNoSuffix + ".Td2";
	if(m_accessObj.LoadTd2Coefs((char*)(LPCSTR)TdName))	
	{
		m_bLoadedTdCoefs = true;
	}

	if(m_bLoadedTdCoefs && m_bLoadedCubeMap)
		m_bDrawMS = true;
	ChangeDrawElements();

}

void CPRTView::OnLoadT1Coefs()
{
	CString T1CName = m_filenameNoSuffix + ".T1C";
	if(m_accessObj.LoadT1Coefs((char*)(LPCSTR)T1CName))	
	{
		m_bLoadedT1Coefs = true;
	}

	if(m_bLoadedT1Coefs && m_bLoadedCubeMap)
		m_bDrawSS = true;
	
	ChangeDrawElements();
}

//HG(Cos, g)
inline float CPRTView::HG(float Cos)
{
	return (1 - m_g * m_g)	/ pow(1 + m_g * m_g - 2 * m_g * Cos, 1.5f);
}

//generate 6*res*res wi and also rename it to wo, shape it to a HG(wi,wo) matrix, save to .hg, //so matlab could SVD it and get g[4][6k], h[4][6k]
//matlab can compute [u s v] = svd(mat(6*16*16, 6*16*16)) in about 5 minutes. no 4Pi.
//My HGmat's wi wo are both outward!!!
void CPRTView::ComputeSaveHGMat(int res)
{
	char str[5];
	itoa(res, str, 10);
	CString fn = "HG";
	fn = fn + str + "g";
	itoa((int)(m_g * 100), str, 10);
	fn = fn + str + ".hg";

	FILE* f;
	if((f = fopen(((char*)(LPCSTR)fn), "wb")) == NULL)
	{
		printf("failed open writing .hg.\n ");
		return;
	}

	float** HGmat = new float*[6*res*res];
	for(int i = 0; i < 6*res*res; ++i)
		HGmat[i] = new float[6*res*res];

	Vec3 wi, wo;
	float hg;

	//int sidewi,offsetwi,  sidewo, offsetwo;
	//for(int wiIdx = 0; wiIdx < 6*res*res; ++wiIdx)
	//{
	//	sidewi = wiIdx / (res*res);
	//	offsetwi = wiIdx % (res*res);
	//	wi = m_cubeMap.Offset2Dir(sidewi, offsetwi, res);
	//	for(int woIdx = wiIdx; woIdx < 6*res*res; ++woIdx)
	//	{
	//		sidewo = woIdx / (res*res);
	//		offsetwo = woIdx % (res*res);
	//		wo = m_cubeMap.Offset2Dir(sidewo, offsetwo, res);
	//		hg = HG(Dot(wi, wo));
	//		HGmat[wiIdx][woIdx] = hg;
	//		HGmat[woIdx][wiIdx] = hg;
	//	}
	//}
	for(int sidewi = 0; sidewi < 6; ++sidewi)
		for(int offsetwi = 0; offsetwi < res*res; ++offsetwi)
		{
			wi = m_cubeMap.Offset2Dir(sidewi, offsetwi, res);

			for(int sidewo = 0; sidewo < 6; ++sidewo)
				for(int offsetwo = 0; offsetwo < res*res; ++offsetwo)
				{
					if(sidewo * res * res + offsetwo < sidewi * res * res + offsetwi)
						continue;
					
					wo = m_cubeMap.Offset2Dir(sidewo, offsetwo, res);

					hg =  HG(-Dot(wi, wo)); //reason: my wi, wo are both outward, but func HG() requires the angle of INWARD wi and outward wo.So cos(pi-<wi,wo>) = -cos(<wi,wo>)
					HGmat[sidewi * res * res + offsetwi][sidewo * res * res + offsetwo] = hg;
					HGmat[sidewo * res * res + offsetwo][sidewi * res * res + offsetwi] = hg;
				}			
		}
	
	for(int i = 0; i < 6*res*res; ++i)
	{
		size_t n = fwrite(HGmat[i], sizeof(float), 6*res*res, f);
		assert(n ==  (size_t)6*res*res);
	}
	fclose(f);

	for(int i = 0; i < 6*res*res; ++i)
		if(HGmat[i]) delete[] HGmat[i];
	delete[] HGmat;

}

void CPRTView::OnUsephaseterm4()
{
	m_usePhaseTerm = 4;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateUsephaseterm4(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_usePhaseTerm == 4);
}

void CPRTView::OnUsephaseterm8()
{
	m_usePhaseTerm = 8;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateUsephaseterm8(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_usePhaseTerm == 8);
}

void CPRTView::OnUsephaseterm16()
{
	m_usePhaseTerm = 16;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateUsephaseterm16(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_usePhaseTerm == 16);
}

void CPRTView::OnUsephaseterm32()
{
	m_usePhaseTerm = 32;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateUsephaseterm32(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_usePhaseTerm == 32);
}

void CPRTView::OnUsephaseterm1()
{
	m_usePhaseTerm = 1;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateUsephaseterm1(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(m_usePhaseTerm == 1);
}

void CPRTView::OnSpec()
{
	_Spec = !_Spec;
	TransedRadiance();
	CalcColor();
	Invalidate(); 
}

void CPRTView::OnUpdateSpec(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(_Spec == 1);
}

void CPRTView::OnViewDrawtexture()
{
	_Tex = !_Tex;
	ChangeDrawElements();
	Invalidate(); 
}

void CPRTView::OnUpdateViewDrawtexture(CCmdUI *pCmdUI)
{
	pCmdUI->SetCheck(_Tex == 1);
}

void CPRTView::OnFileOpentexture()
{
	if(!_Tex)
	{
		printf("!_Tex!\n");
		return;
	}

	char szFilter[] = "bmp Files (*.bmp)|*.bmp|All Files (*.*)|*.*||";

	CFileDialog openDlg(TRUE,NULL,
		NULL,
		OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		szFilter,
		this);
	CString szFilepath;
	
	if(openDlg.DoModal() == IDOK)
	{
		szFilepath = openDlg.GetPathName();
		AUX_RGBImageRec* ppp = auxDIBImageLoad((LPCSTR)szFilepath);
		if(!ppp->data)
			return;
		
		m_texW = ppp->sizeX;
		m_texH = ppp->sizeY;
		m_textureImage.clear();
		m_textureImage.resize(m_texW * m_texH * 4);
		unsigned char* pCol = ppp->data;
		unsigned char* pColImg = &m_textureImage[0];
		for(INT64 i = 0; i < m_texW * m_texH * 3; ++i)
		{
			*pColImg = *pCol;
			if((i % 3) == 2)
			{
				++pColImg;
				*pColImg = 255;
			}
			++pColImg;
			++pCol;
		}		
		if (ppp->data)						// If Texture Image Exists
			free(ppp->data);				// Free The Texture Image Memory
		free(ppp);							// Free The Image Structure
	
		printf("Texture loaded.\n");

		ChangeDrawElements();
		TransedRadiance();
		CalcColor();
		Invalidate();
	}
}
